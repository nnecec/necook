# HTTP
## HTTP定义／简介
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网服务器传输超文本到本地浏览器的传送协议。

HTTP协议是构建在TCP/IP协议之上的，是TCP/IP协议的一个子集，是一个属于应用层的面向对象的协议。协议工作于客户端-服务端架构（C/S）之上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求，服务器根据接收到的请求后，向客户端发送响应信息。
HTTP是一个简单的协议。客户进程建立一条同服务器进程的TCP连接，然后发出请求并读取服务器进程的响应。服务器进程关闭连接表示本次响应结束。服务器进程返回的文件通 常含有指向其他服务器上文件的指针 (超文本链接 )。用户显然可以很轻松地沿着这些链接从一个服务器到下一个服务器。

## TCP/IP协议

1. 应用层

   应用层一般是我们编写的应用程序，其决定了向用户提供的应用服务。应用层可以通过系统调用与传输层进行通信。处于应用层的协议非常多，比如：FTP（File Transfer Protocol，文件传输协议）、DNS（Domain Name System，域名系统）和我们本章讨论的HTTP（HyperText Transfer Protocol，超文本传输协议）等。

2. 传输层
   传输层通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能。
   在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。

3. 网络层
   网络层用来处理在网络上流动的数据包，数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传输给对方。

4. 链路层
   链路层用来处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动、NIC（Network Interface Card，网络适配器）以及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。

   ### TCP三次握手

   从上面的介绍可知，传输层协议主要有两个：TCP协议和UDP协议。TCP协议相对于UDP协议的特点是：TCP协议提供面向连接、字节流和可靠的传输。

   使用TCP协议进行通信的双方必须先建立连接，然后才能开始传输数据。TCP连接是全双工的，也就是说双方的数据读写可以通过一个连接进行。为了确保连接双方可靠性，在双方建立连接时，TCP协议采用了三次握手（Three-way handshaking）策略。

   TCP协议三次握手的描述如下：

   **第一次握手**：客户端发送带有SYN标志的连接请求报文段，然后进入SYN_SEND状态，等待服务端的确认。

   **第二次握手**：服务端接收到客户端的SYN报文段后，需要发送ACK信息对这个SYN报文段进行确认。同时，还要发送自己的SYN请求信息。服务端会将上述的信息放到一个报文段（SYN+ACK报文段）中，一并发送给客户端，此时服务端将会进入SYN_RECV状态。

   **第三次握手**：客户端接收到服务端的SYN+ACK报文段后，会想服务端发送ACK确认报文段，这个报文段发送完毕后，客户端和服务端都进入ESTABLISHED状态，完成TCP三次握手。

   当三次握手完成后，TCP协议会为连接双方维持连接状态。为了保证数据传输成功，接收端在接收到数据包后必须发送ACK报文作为确认。如果在指定的时间内（这个时间称为重新发送超时时间），发送端没有接收到接收端的ACK报文，那么就会重发超时的数据。

## DNS服务

通常我们访问一个网站，使用的是主机名或者域名来进行访问的。因为相对于IP地址（一组纯数字），域名更容易让人记住。但TCP/IP协议使用的是IP地址进行访问的，所以必须有个机制或服务把域名转换成IP地址。DNS服务就是用来解决这个问题的，它提供域名到IP地址之间的解析服务。

DNS服务是通过DNS协议进行通信的，而DNS协议跟HTTP协议一样也是应用层协议。由于我们的重点是HTTP协议，所以这里不打算对DNS协议进行详细的分析，我们只需要知道可以通过DNS服务把域名解析成IP地址即可。

## HTTP与TCP/IP、DNS的关系

当客户端访问Web站点时，首先会通过DNS服务查询到域名的IP地址。然后浏览器生成HTTP请求，并通过TCP/IP协议发送给Web服务器。Web服务器接收到请求后会根据请求生成响应内容，并通过TCP/IP协议返回给客户端。

## HTTP主要特点
1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。
2. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
3. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
5. 支持B/S及C/S模式。

## URI/URL
HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。URL（全称是UniformResourceLocator）是一种特殊类型的URI，包含了用于查找某个资源的足够的信息URL, 中文叫统一资源定位符，是互联网上用来标识某一处资源的地址。
- URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。URI一般由三部组成：①访问资源的命名机制；②存放资源的主机名；③资源自身的名称，由路径表示，着重强调于资源。
- URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。URL一般由三部组成：①协议(或称为服务方式)；②存有该资源的主机IP地址(有时也包括端口号)；③主机资源的具体地址。如目录和文件名等。
- URN，uniform resource name，统一资源命名，是通过名字来标识资源但不指定如何定位资源。

## 请求消息 Request
一个HTTP请求格式由：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。
![](http://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png)
- Get请求例子

  ```
  GET /562f25980001b1b106000338.jpg HTTP/1.1
  Host    img.mukewang.com
  User-Agent    Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36
  Accept    image/webp,image/,/*;q=0.8
  Referer    http://www.imooc.com/
  Accept-Encoding    gzip, deflate, sdch
  Accept-Language    zh-CN,zh;q=0.8
  ```

1. 请求行：（第一行）用来说明请求类型，要访问的资源以及所使用的HTTP版本。
2. 请求头部：（第二至七行）紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。HOST将指出请求的目的地。User-Agent服务器端和客户端脚本都能访问它，它是浏览器类型检测逻辑的重要基础。该信息由你的浏览器来定义，并且在每个请求中自动发送。
3. 空行：（第八行）请求头部后面的空行是必须的。
4. 请求数据：也叫主体，可以添加任意的其他数据。

- POST请求例子

  ```
  POST / HTTP1.1
  Host:www.wrox.com
  User-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)
  Content-Type:application/x-www-form-urlencoded
  Content-Length:40
  Connection: Keep-Alive

  name=Professional%20Ajax&publisher=Wiley
  ```

​	第一部分：请求行，第一行明了是post请求，以及http1.1版本。
​	第二部分：请求头部，第二行至第六行。
​	第三部分：空行，第七行的空行。
​	第四部分：请求数据，第八行。

## 响应消息 Response
由四个部分组成，分别是：状态行、消息报头、空行和响应正文。
	HTTP/1.1 200 OK
	Date: Fri, 22 May 2009 06:07:21 GMT
	Content-Type: text/html; charset=UTF-8
	
	<html>
	      <head></head>
	      <body>
	            <!--body goes here-->
	      </body>
	</html>
1. 状态行：由HTTP协议版本号， 状态码， 状态消息 三部分组成。
2. 消息报头：用来说明客户端要使用的一些附加信息。
3. 空行：消息报头后面的空行是必须的。
4. 响应正文：服务器返回给客户端的文本信息。

常见的状态码有如下几种：

- `200 OK` 客户端请求成功
- `301 Moved Permanently` 请求永久重定向
- `302 Moved Temporarily` 请求临时重定向
- `304 Not Modified` 文件未修改，可以直接使用缓存的文件。
- `400 Bad Request` 由于客户端请求有语法错误，不能被服务器所理解。
- `401 Unauthorized` 请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用
- `403 Forbidden` 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因
- `404 Not Found` 请求的资源不存在，例如，输入了错误的URL
- `500 Internal Server Error` 服务器发生不可预期的错误，导致无法完成客户端的请求。
- `503 Service Unavailable` 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。

## HTTP工作原理
 HTTP 请求/响应的步骤：

1. 客户端到Web服务器建立一个TCP套接字连接。
2. 发送HTTP请求
3. 服务器接受请求并返回HTTP响应
4. 释放连接TCP连接:若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;
5. 客户端浏览器解析HTML内容
   在浏览器地址栏键入URL，按下回车之后会经历以下流程：
6. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
7. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
8. 浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器;
9. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
10. 释放 TCP连接;
11. 浏览器将该 html 文本并显示内容; 　　
## GET和POST的区别
- GET在浏览器回退时是无害的，而POST会再次提交请求。

- GET产生的URL地址可以被Bookmark，而POST不可以。

- GET请求会被浏览器主动cache，而POST不会，除非手动设置。

- GET请求只能进行url编码，而POST支持多种编码方式。

- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

- GET请求在URL中传送的参数是有长度限制的，而POST没有。

- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

- GET参数通过URL传递，POST放在Request body中。

  GET和POST本质上就是TCP链接，并无差别。以上差别是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 

  GET和POST还有一个重大区别，简单的说：GET产生一个TCP数据包；POST产生两个TCP数据包。长的说：对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

## HTTP头信息
- **Content-type**：表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。

- **Expires**：这个头部是在HTTP1.0中定义的，它指定了一个绝对的过期日期，如果过期日期已经过了，就说明文档不再新鲜了。但是使用Expires存在服务器端时间和浏览器时间不一致的问题，我们基本上是不会使用这个头部。

- **Cache-Control**：既然我们说Expires是不推荐的用法，那么肯定要有个替代方案。在HTTP1.1中定义了一个文档从第一次生成开始到不再新鲜、无法使用为止的最长使用期，并且以秒为单位。用法如下所示：Cache-Control: max-age=484200。

  Cache-Control还有其他定义方式。

  1. no-cache：所有内容都不会被缓存，每次都向服务器发起请求。可以具体指定某个字段，如no-cache=set-cookie，它告知浏览器当遇到set-cookie时不要使用缓存内容，而是去向服务器请求。
  2. no-store：让浏览器直接向服务器发起请求。和no-chche的区别是，no-store每次的请求和响应都不会被缓存，都是一次全新的操作。no-cache则还是会缓存，而且请求时还是会先拿到缓存内容，然后不做验证直接去向服务器发起请求。
  3. public：所有内容都将被缓存
  4. private：告知浏览器只缓存单个用户的响应，可以指定具体字段，private=username，此时名为username的标头内容，将不会被共享缓存。

- **Last-Modified**：该头部配合cache-control使用，服务器在响应中会带有一个Last-Modified的头部，告诉浏览器该资源的最后修改时间。请求头为If-Modified-Since。

  若响应包中Cache-Control:max-age 或 Expires 字段，则会重新设置缓存的过期时间，于是，浏览器又可以不需要向服务器发起请求了。

- **Etag**：该头部和Last-Modified的作用类似。Etag的字段和值是一个特殊值。请求头为If-None-Match。

  > Last-Modified和Etag的区别

  1. Last-Modified只能精确到秒，有些时候，文件会在1秒内被更改很多次，使用Last-Modified则无法准确的标志文件的更改时间。

  2. 有时会定时生成一些文件，但是内容是不变的，或者仅仅修改变动的时间，此时我们并希望浏览器还是使用缓存的资源，Last-Modified则无法满足我们了。

  3. Etag又服务器或者开发者生成的一个唯一特殊标志值，可以更加有效的控制缓存。资源变更则更新该值，没有变更则不更新该值，简洁粗暴。

     两者是可以通用的，此时我们应该让服务器优先验证Etag，再去验证Last-Modified，只要有一方认为资源没有变动，就会进行304响应。

  > Etag/lastModified过程如下：

  1. 客户端请求一个页面资源，会根据缓存设置缓存页面。
  2. 服务器返回页面，并在给资源添加Last-Modified/ETag。
  3. 客户端展现该页面，浏览器则会缓存Last-Modified/ETag的字段和值。Last-Modified为资源修改时间，Etag是一个特殊标记值。
  4. 客户再次请求页面，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。当资源过期时，在对服务器发起的请求头中会带有一个If-Modified-Since/If-None-Match的请求头。
  5. 服务器检查该Last-Modified或ETag，并判断该页面自上次客户端请求之后还未被修改，相同，说明资源没有更改，返回304。不同，说明资源已经更改，返回最新资源，响应码为200，并带有最新的Last-Modified/Etag值。
## HTTP缓存

缓存行为主要由缓存策略决定，而缓存策略由内容拥有者设置。这些策略主要通过特定的HTTP头部来清晰地表达。
当一个用户发起一个静态资源请求的时候，浏览器会通过以下几步来获取资源：

1. 本地缓存阶段：先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，完全不会发送http请求到服务器；
2. 协商缓存阶段：如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器,然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；
3. 缓存失败阶段：当服务器发现请求的资源已经修改过，或者这是一个新的请求(在本来没有找到资源)，服务器则返回该资源的数据，并且返回200， 当然这个是指找到资源的情况下，如果服务器上没有这个资源，则返回404。

这时我们发现，询问的过程还是需要发起一起HTTP请求，得到的结果是继续使用缓存。PC端还好，对于移动端，一次请求还是有代价的，因此我们需要有一种方式来消灭这种304。

此时，在前端我们采取的方式是，对这些静态文件，如js,css的文件名中加入版本名或者MD5值，如bundle.d5d02a02.js，bundle.v1.js，并且设置Cache-Control:max-age=31536000，即1年的使用时间。这样1年内我们都不会发起新的请求。如果资源文件被修改了，则使用新的MD5值或者版本名进行命名，如bundle.d43d12d3.js，bundle.v2.js。这样便能有效的避免304了。

**合理的利用缓存机制：**

1. 使用一致的网址：如果在不同的网址上提供相同的内容，那么将会多次获取和存储相同的内容。提示：网址是区分大小写的！
2. 确保服务器提供验证码 (ETag)：通过验证码，如果服务器上的资源未被更改，就不必传输相同的字节。
3. 确定代理缓存可以缓存哪些资源：对所有用户的响应完全相同的资源很适合由 CDN 或其他代理缓存进行缓存。
4. 确定每个资源的最优缓存周期：不同的资源可能有不同的更新要求。审查并确定每个资源适合的 max-age。
5. 确定网站的最佳缓存层级：对 HTML 文档组合使用包含内容指纹码的资源网址以及短时间或 no-cache 的生命周期，可以控制客户端获取更新的速度。
6. 变动最小化：有些资源的更新比其他资源频繁。如果资源的特定部分（例如 JavaScript 函数或一组 CSS 样式）会经常更新，应考虑将其代码作为单独的文件提供。这样，每次获取更新时，剩余内容（例如不会频繁更新的库代码）可以从缓存中获取，确保下载的内容量最少。

## 参考
1. [ 关于HTTP协议，一篇就够了 ][1]
2. [ 99%的人都理解错了HTTP中GET与POST的区别 ][2]
3. [ 浏览器缓存浅析 ][3]
4. [透过浏览器看HTTP缓存][4]
[1]:http://www.jianshu.com/p/80e25cb1d81a "关于HTTP协议，一篇就够了"
[2]:http://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd "99%的人都理解错了HTTP中GET与POST的区别"
[3]:https://github.com/zhengweikeng/blog/issues/5 "浏览器缓存浅析"
[4]:http://www.admin10000.com/document/6299.html "透过浏览器看HTTP缓存"
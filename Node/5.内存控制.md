# 5.内存控制

1. V8的垃圾回收机制与内存限制

   1. Node与V8

   2. V8的内存限制：由于V8的管理和分配，Node使用内存时只能使用部分内存

   3. V8的对象分配：所有的JavaScript对象都是通过堆来进行分配的。声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制。V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。在用于浏览器的场景下直接限制堆内存是一个好的选择。在V8初始化时可以调整内存限制的大小。

   4. V8的垃圾回收机制

      1. V8的主要垃圾回收算法

         主要基于分代式垃圾回收机制，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代施以更高效的算法。

         - V8的内存分代

           在V8中，主要将内存分为新生代和老生代两代。V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。V8堆内存最大值在64位系统上为1464MB，32位系统上则为732MB。

         - Scavenge算法

           Scavenge的具体实现中，主要采用了Cheney算法。Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。

           Scavenge是典型的牺牲空间换取时间的算法。

           当一个对象经过多次复制依然存活，它将被认为是生命周期较长的对象。这种对象随后会被移动到老生代，采用新的算法管理。这种过程称为晋升。对象晋升主要有两个条件，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。

           如果一个对象经历过一次Scavenge回收，或者要占用超过25%的To空间，则将这个对象晋升到老生代空间中。

         - Mark-Sweep & Mark-Compact

           主要用于在老生代中进行垃圾回收。Mark-Sweep分为标记和清除两个阶段。Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。最大的问题是在一次标记清除回收后，内存空间会出现不连续的状态，会对后续的内存分配造成问题。

           Mark-Compact是标记整理的意思。在对象标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

           V8主要使用Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才能用Mark-Compact。


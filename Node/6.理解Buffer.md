# 6.理解Buffer

在Node中，应用需要处理网络协议、操作数据库、处理图片、接受上传文件等。

1. Buffer结构

   1. 模块结构

      Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能的部分用JavaScript实现。

      Buffer所占用的内存不是通过V8分配的，属于堆外内存。

   2. Buffer对象

      Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。

      Buffer可以访问length属性得到长度，也可以通过下标访问元素，在构造对象时也十分相似。

      给元素赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果大于255，则逐次减256。

   3. Buffer内存分配

      Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的。因为处理大量的字节数据不能采用需要就向操作系统申请一点内存的方式，这可能造成大量的内存申请的系统调用。

      为了高效地使用申请来的内存，Node采用了slab分配机制。slab是一种动态内存管理机制，slab就是一块申请好的固定大小的内存区域，具有如下3种状态：

      1. full：完全分配状态
      2. partial：部分分配状态
      3. empty：没有被分配状态

      通过`new Buffer(size)`分配制定大小的Buffer对象

      1. 分配小Buffer对象

         如果制定Buffer的大小少于8KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它。slab状态由empty变为partial。

         当再次创建一个Buffer对象时，构造过程中将判断slab的剩余空间是否足够。如果slab剩余的空间不够，将会构造新的slab，原slab剩余的空间会造成浪费。

      2. 分配大Buffer对象

         如果需要分配超过8KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab单元将会被这个大Buffer对象独占。

      3. 小结

         真正的内存是在C++层面提供的，JavaScript层面只是使用它。当进行小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JavaScript到操作系统之间不必有过多的内存申请方面的系统调用。对于大块的Buffer而言，则直接使用C++层面提供的内存。

2. Buffer的转换

   Buffer对象可以与字符串之间相互转换

   1. 字符串转Buffer

      字符串转Buffer对象主要是通过构造函数完成的：

      `new Buffer(str, [encoding]);`

   2. Buffer转字符串

      Buffer对象的toString()可以将Buffer对象转换为字符串：

      `buf.toString([encoding], [start], [end])`

   3. Buffer不支持的编码类型

      Buffer.isEncoding(encoding)判断编码是否支持转换

3. Buffer的拼接

   用Buffer拼接的方式获取数据，一旦输入流中有宽子节编码时，问题就会暴露出来。

   1. 乱码是如何产生的

      宽子节字符串在Buffer中有被截断的情况

   2. setEncoding()与string_decoder()

      可读流有一个设置编码的方法`setEncoding()`，该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。

      可读流对象在内部设置了一个decoder对象，每次data事件都通过该decoder对象进行Buffer​岛字符串的解码，然后传递给调用者。


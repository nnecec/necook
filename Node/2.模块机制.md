# 2.模块机制

## CommonJS规范

1. 出发点

   JavaScript规范的缺陷：

   1. 没有模块系统
   2. 标准库较少
   3. 没有标准接口
   4. 缺乏包管理系统：导致JavaScript应用中基本没有自动加载和安装依赖的能力。

   CommonJS规范的提出，不仅为了可以利用JavaScript开发富客户端应用，而且可以编写以下应用

   - 服务器端JavaScript应用程序
   - 命令行工具
   - 桌面图形界面应用程序
   - 混合应用

2. 模块规范

   1. 模块引用

      `var math = require('math')`

   2. 模块定义

      上下文提供了exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node中，一个文件就是一个模块，将方法挂载在exports对象上作为属性即可定义导出的方式。

      ```javascript
      //math.js
      exports.add=function(){...}

      //other.js
      var math = require('math')
      math.add(...)
      ```

   3.  模块标识

      模块标识其实就是传递给`require()`方法的参数

## Node的模块实现

在Node中引入模块，需要经历如下3个步骤

1. 路径分析
2. 文件定位
3. 编译执行

在Node中，模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块。

- 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块被直接加载进内存中，引入这部分核心模块时，文件定位和编译执行这两个步骤可以省略掉，并在路径分析中优先判断
- 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程

详细的模块加载过程

1. 优先从缓存中加载

   Node缓存编译和执行之后的对象。`require()`方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。

2. 路径分析和文件定位

   对于不同的标识符，模块的查找和定位有不同程度上的差异。

   1. 模块标识符分析

      - 核心模块，如`http`、`fs`、`path`；
      - `.`或`..`开始的相对路径文件模块；
      - 以`/`开始的绝对路径文件模块；
      - 非路径形式的文件模块，如自定义的`connect`模块；

      核心模块：文件模块的标识符需要与核心模块的不同，或换用路径的方式。

      路径形式的文件模块：`require()`方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果放到缓存中，以使二次加载时更快。

      自定义模块：特殊的文件模块，可能是一个文件或者包的形式

      ​

      模块路径：生成规则沿路径向上逐级递归，直到根目录下的`node_modules`目录

   2. 文件定位

      - 文件扩展名分析

        Node会按.js、.json、.node的次序补足扩展名。在尝试的过程中，需要调用`fs`模块同步阻塞式地判断文件是否存在。

      - 目录分析和包

        可能没有查找到相应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常出现，此时Node会将目录当做一个包来处理。

        首先Node在当前目录下查找package.json(CommonJS包规范定义的包描述文件)，通过`JSON.parse()`解析出包描述对象，从中取出`main`属性指定的文件名进行定位。

        如果`main`属性指定的文件名错误，或者压根没有`package.json`，Node会将index当作默认文件名。如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果没有查找到目标文件，则会抛出查找失败的异常。

   3. 模块编译

      - .js文件。通过`fs`模块同步读取文件后编译执行。
      - .node文件。这是用C/C++编写的扩展文件，通过`dlopen()`方法加载最后编译生成的文件。
      - .json文件。通过`fs`模块同步读取文件后，用`JSON.parse()`解析返回结果。
      - 其余扩展名文件。它们都被当作.js文件载入。

   ​	每一个编译成功的模块都会将其文件路径作为索引换存在`Module._cache`对象上。
# 8.构建Web应用

1. 基础功能

   request事件发生于网络连接建立，客户端向服务器端发送报文，服务器端解析报文，发现HTTP请求的报头时。在已出发request事件前，它已准备好`ServerRequest`和`ServerResponse`对象以供对请求和响应报文的操作。

   1. 请求方法

      GET、POST、HEAD、DELETE、PUT、CONNECT等方法。请求方法存在于报文的第一行的第一个单词。HTTP_Parser在解析请求报文的时候，将报文头抽取出来，设置为`req.method`。

   2. 路径解析

      路径部分存在于报文的第一行的第二部分，如下所示

      ```
      GET /path?foo=bar HTTP/1.1
      ```

      HTTP_Parser将其解析为`req.url`。客户端代理会将URL地址解析成报文，将路径和查询部分放在报文第一行。hash部分会被丢弃。

   3. 查询字符串

      地址栏中路径后的?foo=bar&baz=val字符串就是查询字符串，形成请求报文首行的第二部分。

   4. Cookie

      1. 初识Cookie

         服务器向客户端发送Cookie，浏览器将Cookie保存，之后每次浏览器都会将Cookie发向服务器端。

         - path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个Cookie
         - Expires和Max-Age用来告知浏览器这个Cookie何时过期，如果不设置该选项，在关闭浏览器时会丢失这个Cookie。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将国庆，Max-Age则告知浏览器此Cookie多久后过期。
         - HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值
         - Secure。当Secure=true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器进行会话验证，如果是HTTP连接则不会传递该信息。

      2. Cookie的性能影响

         - 减少Cookie的大小
         - 为静态组件使用不同的域名
         - 减少DNS查询

   5. Session

      Cookie可以在前后端修改，为了解决敏感数据的问题，Session数据只保留在服务器端，客户端无法修改。将每个客户和服务器中的数据一一对应起来常见的两种实现方式

      1. 基于Cookie来实现用户和数据的映射

         Session有效期普遍设置为20分钟，如果在20分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。

         一旦服务器端起用了Session，将约定一个键值作为Session的口令，一旦服务器检查到用户请求Cookie中没有携带该值，就会生成一个唯一且不重复的值，并设定超时时间。 

         每个请求到来时，检查Cookie中的口令与服务器端的数据，如果过期就重新生成，需要在响应给客户端时设置新的值。

      2. 通过查询字符串来实现浏览器端和服务器端数据的对应

         原理是检查请求的查询字符串，如果没有值，会生成新的带值的URL，然后形成跳转，让客户端重新发起请求。

      另外有利用HTTP请求头中的ETag方法。

      1. Session与内存

         将Session数据直接存在变量sessions中，就等于将数据存放在内存中，如果数据量增多，则会引起垃圾回收的频繁扫描，引起性能问题。另一个问题则是我们可能为了利用多核CPU而启动多个进程，用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存的，用户的Session可能会引起错乱。

         为了解决性能问题和Session数据无法跨进程共享的问题，常用的方案是将Session集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是Redis、Memcached等。

         采用第三方缓存来存储Session会引起网络访问的问题。理论上访问网络中的数据要比访问本地磁盘中的数据速度要慢，因为涉及到握手、传输以及网络终端自身的磁盘I/O等，但依然采用这些高速缓存的理由：

         - Node与缓存服务保持长连接，而非短连接，握手导致的延迟只影响初始化。
         - 高速缓存直接在内存中惊醒数据存储和访问。
         - 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。

      2. Session与安全

         口令依然可能被伪造。

         将口令通过私钥加密进行签名。另一种方案是将客户端的某些独有信息与口令作为原值进行签名。

         导致口令泄漏的漏洞：

         - XSS漏洞

           跨站脚本攻击(Cross Site Scripting)，通常都是由网站开发者决定哪些脚本可以执行在浏览器端，形成原因多数是用户的输入没有被转移，而被直接执行。

   6. 缓存

      在普通的GET请求报文中，附带If-Modified-Since字段，值为数据最后修改时间，如果服务器端没有新的版本则响应304状态码。

      时间戳有一定缺陷：

      - 时间戳改动但内容不一定改动
      - 只能精确到秒级别，频繁的内容变更无法生效

      服务端决定生成规则，ETag的请求和响应是If-None-Match/ETag。以上两种方法都需要发送一次请求。

      在服务器端在响应内容时，让浏览器明确地将内容缓存起来。

      - 添加`Expires`或`Cache-Control`到报文头中

        Expires是一个GMT格式的时间字符串。为Cache-Control设置max-age值以倒计时的方式计算过期时间。max-age会覆盖Expires。

      - 配置`ETags`

      - 让Ajax可缓存

      清除缓存，为文件添加hash值。

   7. Basic认证

      当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。

      如果一个页面需要Basic认证，它会检查请求报文头中的Authorization字段的内容，该字段的值由认证方式和加密值构成。

      如果用户首次访问该网页，URL地址中没携带认证内容，那么浏览器会响应一个401未授权的状态码。

2. 数据上传

   头部报文能够让服务器端进行大多数业务逻辑操作，但无法携带大量的数据，通过报头的Transfer-Encoding或Content-Length判断是否带有内容。

   1. 表单数据

      默认的表单提交`Content-Type: application/x-www-form-urlencoded`

   2. 其他格式

      JSON文件，XML文件

   3. 附件上传

      `Content-Type: multipart/form-data; boundary=AaB03x`

      `Content-Length: 18231`

      boundary指定的是每部分内容的分界符，Content-Length必须确保是报文体的长度。

   4. 数据上传与安全

      1. 内存限制

         在解析表单、JSON和XML部分，采取先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。一旦数据量过大，将发生内存被占光的情况。解决方案：

         - 限制上传内容的大小
         - 通过流式解析，将数据流导向磁盘中，Node只保留文件路径等小数据

      2. CSRF

         全称Cross-Site Request Forgery，意为跨站请求伪造，伪装并盗取另一个网站的Cookie信息。解决方法为在Session中赋予一个随机值，做一次校验去识别该请求是否是伪造的。

3. 路由解析

   1. 文件路径型

      1. 静态文件

         URL的路径与网站目录的路径一致

      2. 动态文件

         Web服务器根据URL路径找到对应的文件，如index.asp或index.php。

   2. MVC

      主要思想是将业务逻辑按职责分离：控制器(Controller)、模型(Model)和视图(View)。

      最经典的分层模式：

      - 路由解析，根据URL寻找到对应的控制器和行为
      - 行为调用相关的模型，进行数据操作
      - 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端

      1. 手工映射

         手工配置路由

         - 正则匹配
         - 参数解析

      2. 自然映射

   3. RESTful

      全称REpresentational State Transfer，中文含义为表现层状态转化。

   4. 中间件

      1. 异常处理

         中间件异步产生的异常需要自己传递出来

      2. 中间件与性能

         业务逻辑往往在最后才执行，主要提升的点：

         - 编写高效的中间件

           提升单个处理单元的处理速度，尽早调用next()执行后续逻辑。常见优化方法：

           - 使用高效的方法。必要时通过jsperf.com测试基准性能
           - 缓存需要重复计算的结果
           - 避免不必要的计算。

         - 合理使用路由

   5. 页面渲染

      1. 内容响应

         服务器端响应的报文，最终都要被终端处理。

         1. 内容响应

            1. MIME：Content-Type。不同的文件类型具有不同的MIME值
            2. 附件下载：Content-Disposition。客户端会根据它的值判断是应该将报文数据当做即使浏览的内容(inline)还是可下载的附件(attachment)。
            3. 响应JSON
            4. 响应跳转

         2. 视图渲染

            render()接受参数模版路径和数据，返回HTML片段

         3. 模版

            四个要素：模版语言、包含模版语言的模版文件、拥有动态数据的数据对象、模版引擎。

            1. 模版引擎

               语法分解，处理表达式，生成待执行的语句，与数据一起执行生成最终字符串。

            2. with的应用

            3. 模版逻辑

            4. 集成文件系统

            5. 子模版

            6. 布局视图

            7. 模版性能

               缓存模版文件、缓存模版文件编译后的函数、优化模版中的执行表达式

         4. Bigpipe

            为了解决重数据页面的加载速度问题。解决思路是将页面分割成多个部分，逐步输出填充页面。

            1. 页面布局框架
            2. 持续数据输出
            3. 前端渲染


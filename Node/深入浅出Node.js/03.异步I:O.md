# 3.异步 I/O

1. 为什么要异步 I/O

   1. 用户体验

      请求资源的时间；数据分布到多台服务器上，分布式将成为常态。I/O 是昂贵的，分布式 I/O 是更昂贵的。

   2. 资源分配

      完成互不相关任务的主流方法：

      - 单线程串行依次执行：会因阻塞 I/O 导致硬件资源得不到更优使用
      - 多线程并行完成：死锁、状态同步等问题

      Node：利用单线程，远离多线程死锁、状态同步等问题；利用异步 I/O，让单线程远离阻塞。

      为了弥补单线程无法利用多核 CPU 的缺点，Node 提供了类似 Web Workers 的子进程。

2. 异步 I/O 实现现状

   1. 异步 I/O 与非阻塞 I/O

      操作系统将所有输入输出设备抽象为文件，阻塞 I/O 完成整个获取数据的过程，非阻塞 I/O 则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。

      为了获取完整的数据，应用程序需要重复调用 I/O 操作来确认是否完成。这种技术叫做轮询。

      轮询技术主要有以下：

      - read。最原始、性能最低的一种。通过重复调用来检查 I/O 的状态来完成完整数据的读取。在得到最终数据前，CPU 一直耗用在等待上。
      - select。通过文件描述符上的事件状态来判断。由于采用一个 1024 长度的数组来存储状态，最多可以同时检查 1024 个文件描述符。
      - poll。采用链表的方式避免数组长度的限制，能避免不必要的检查。文件描述符较多的时候，性能十分低下。
      - epoll。该方案事 Linux 下效率最高的 I/O 事件通知机制。在进入轮询的时候如果没有检查到 I/O 事件，将会进行休眠，直到事件将它唤醒。它真实利用了事件通知、执行回调的方式，而不是遍历查询。

   2. 理想的非阻塞异步 I/O

      应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在 I/O 完成后通过信号或回调将数据传递给应用程序。

   3. 现实的异步 I/O

      让部分线程进行 阻塞 I/O 或者 非阻塞 I/O 加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将 I/O 得到的数据进行传递。

      Windows 下 IOCP 的异步 I/O 模型。

      Node 的单线程仅仅只是 JavaScript 执行在单线程中。无论在 \*nix 还是 Windows 平台，内部完成 I/O 任务的另有线程池。

3. Node 的异步 I/O

   1. 事件循环

      Node 自身的执行模型——事件循环。

      启动进程时，Node 便会创建一个类似于`while(true)`的循环，每执行一次循环体的过程称为 Tick。每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。

   2. 观察者

      Tick 的过程中，由观察者判断是否有事件需要处理。每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。观察者将事件分类并收集。

      事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，为 Node 提供不通类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。

   3. 请求对象

      从 JavaScript 发起调用到内核执行完 I/O 操作的过渡过程中，存在一种中间产物，它叫做请求对象。请求对象是异步 I/O 过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完毕后的回调处理。

   4. 执行回调

      组装好请求对象、送入 I/O 线程池等待执行，实际上完成了异步 I/O 的第一部分，回调通知是第二部分。线程池中的 I/O 操作调用完毕之后，会将获取的结果储存在 req->result 属性上，然后通知 IOCP，告知当前对象操作已经完成。
      在这个过程中，还动用了事件循环的 I/O 观察者。在每次 Tick 的执行中，它会调用 IOCP 相关方法检查线程池中是否有执行完的请求。I/O 观察者回调函数的行为就是取出请求对象的 result 属性作为参数，取出 oncomplete_sym 属性作为方法，然后调用执行，以此达到调用 JavaScript 中传入的回调函数的目的。

      事件循环、观察者、请求对象、I/O 线程池这四者共同构成了 Node 异步 I/O 模型的基本要素。

      ![3-13](./img/3-13.png)

   5. 小结

      在 Node 中，除了 JavaScript 是单线程外，Node 自身是多线程的，只是 I/O 线程使用的 CPU 较少。除了用户代码无法并行执行外，所有的 I/O 则是可以并行起来的。

4. 非 I/O 的异步 API

   1. 定时器：`setTimeout()`和`setInterval()`

      调用定时器会被插入到定时器观察者内部的一个红黑树中。每次 Tick 执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。

      定时器的问题在于，它并非精确的，如果某一次循环占用的时间较多，那么下次循环时，它也许已经超时很久了。

   2. `process.nextTick()`

      定时器需要动用红黑树，创建定时器对象和迭代等操作，`setTimeout(fn, 0)`的方式较为浪费性能。`process.nextTick()`方法的操作相对更高效。

   3. `setImmediate()`

      `process.nextTick()`中的回调函数执行的优先级要高于`setImmediate()`。`process.nextTIck()`属于 idle 观察者，`setImmediate()`属于 check 观察者。在每一个轮循环检查中，idle 观察者先于 I/O 观察者，I/O 观察者先于 check 观察者。

      在具体实现上，`process.nextTick()`的回调函数保存在一个数组中，`setImmediate()`的结果则是保存在链表中。在行为上，`process.nextTick()`在每轮循环中会将数组中的回调函数全部执行完，而 `setImmediate()`在每轮循环中执行链表中的一个回调函数。(可以理解为，在一个循环中将所有接受到的`process.nextTIck()`执行掉，而`setImmediate()`则是一个循环执行一个。)

5. 事件驱动与高性能服务器

   几种经典的服务器模型：

   - 同步式。一次只能处理一个请求，并且其余请求都处于等待状态。
   - 每进程／每请求。为每个请求启动一个进程，这样可以处理多个请求，但它不具备扩展性，因为系统资源只有这么多。
   - 每线程／每请求。为每个请求启动一个线程来处理。由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光。

   Node 通过事件驱动的方式处理请求，无需为每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任务时因为线程较少，上下文切换的代价很低。这是 Node 高性能的一个原因。

# 9.玩转进程

JavaScript 运行在单个进程的单个线程上。带来的好处：程序状态是单一的，在没有多线程的情况下没有锁、线程同步问题，操作系统在调度时也因为较少上下文的切换，可以很好地提高 CPU 的使用率。

问题一：如何充分利用多核 CPU 服务器

问题二：如何保证进程的健壮性和稳定性

1. 服务模型的变迁

   1. 同步

      最早的服务器，执行模型是同步的，服务模式是一次只为一个请求服务，所有请求都得按次序等待服务。QPS 为 1/N。

   2. 复制进程

      为了解决同步架构的并发问题，改进是通过进程的复制同时服务更多的请求和用户。这样每个连接都需要一个进程来服务，在进程复制的过程中，需要复制进程内部的状态，复制较多的数据会导致启动缓慢。为了解决启动缓慢的问题，引入了预复制。进程数上线为 M，QPS 为 M/N。

   3. 多线程

      为了解决进程复制中的浪费问题，引入多线程服务模型，让一个线程服务一个请求。线程相对进程的开销要小许多，并且线程之间可以共享数据，可以减少创建和销毁线程的开销。由于每个线程都拥有自己独立的堆栈，占用一定的内存空间。由于一个 CPU 核心在一个时刻只能做一件事情，当线程数量过多时，时间将会被耗用在上下文切换中。

   4. 事件驱动

      为了解决高并发问题，基于事件驱动的服务模型出现了。由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于 CPU 的计算能力，它的上限决定这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响。

2. 多进程架构

   著名的 Master-Worker 模式，又称主从模式。进程分为两种：主进程和工作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主线程负责调度或管理工作进程。工作进程负责具体的业务处理。

   1. 创建子进程

      `child_process`模块给予 Node 可以随意创建子进程的能力。四个方法：

      - spawn()：启动一个子进程来执行命令。
      - exec()：启动一个子进程来执行命令，有一个回调函数获知子进程的状况。
      - execFile()：启动一个子进程来执行可执行文件。
      - fork()：与 spawn()类似，创建 Node 的子进程只需指定要执行的 JavaScript 文件模块。

      exec()和 execFile()可以设置超时，exec()适合执行已有的命令，execFile()适合执行文件。

   2. 进程间通信

      WebWorker 允许创建工作线程并在后台运行。主线程与工作线程之间通过`onmessage()`和`postMessage()`进行通信，子进程对象则由`send()`方法实现主进程向子进程发送数据，`message`事件实现收听子进程发来的数据。

      - 进程间通信原理

        IPC 全称 Inter-Process Communication，即进程间通信。Node 中实现 IPC 通道的是管道技术，表现在应用层上的进程通信只有简单的 message 事件和 send()方法。父进程实际创建子进程之前，会创建 IPC 通道并监听，然后真正创建子进程，子进程在启动的过程中，根据文件描述符去连接这个已存在的 IPC 通道。

   3. 句柄传递

      为了解决多个进程监听同一个端口的问题，引入了发送句柄的功能，`send()`方法的第二个可选参数就是句柄。

      句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述符。

      1. 句柄发送与还原

         可以发送的句柄类型包括如下几种：

         - net.Socket。TCP 套接字。
         - net.Server。TCP 服务器。
         - net.Native。C++层面的 TCP 套接字或 IPC 管道。
         - dgram.Socket。UDP 套接字。
         - dgram.Native。C++层面的 UDP 套接字。

      2. 端口共同监听

3. 集群稳定之路

   需要考虑的细节：

   - 性能问题
   - 多个工作进程的存活状态管理
   - 工作进程的平滑重启
   - 配置或者静态数据的动态重新载入

   1. 进程事件

      - error：当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。
      - exit：子进程退出时触发该事件，子进程如果是正常退出，这个时间的第一个参数为退出码，否则为 null。如果进程是通过 kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。
      - close：在子进程的标准输入输出流中止时触发该事件，参数与 exit 相同。
      - disconnect：在父进程或子进程中调用`disconnect()`方法时触发该事件，在调用该方法时将关闭监听 IPC 通道。

   2. 自动重启

      一旦有未捕获的异常出现，工作进程就会立即停止接受新的连接，当所有链接断开后，退出进程。主进程在侦听到工作进程的 exit 后，将会立即启动新的进程服务，以保证整个集群中总是有进程在为用户服务。

      1. 自杀信号

         不能等到工作进程退出后才重启新的工作进程。工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接受新的连接，当所有连接断开后才退出。主进程在接受到自杀信号后，立即创建新的工作进程服务。

         有可能是长连接，为已有连接的断开设置一个超时时间，在限定时间里强制退出。

      2. 限量重启

         工作进程不能无限制地被重启，启动中或刚启动后就收到错误会导致频繁重启，超过限制就出发 giveup 事件，放弃重启工作进程这个重要事件。

      3. 负载均衡

         再多进程之间监听相同的端口，使得用户请求能够分散到多个进程上进行处理，保证多个处理单元工作量公平的策略叫负载均衡。

         Node 默认提供的机制是采用操作系统的抢占式策略。即在一堆工作进程中，闲着的进程怼到来的请求进行抢夺。进程的繁忙同时受 CPU 和 I/O 的影响。

         新的策略叫 Round-Robin，又叫轮叫调度，工作方式由主进程接受连接，将其依次分发给工作进程。分发的策略是在 N 个工作进程中，每次选择第`i = (i+1) mod n`个进程

      4. 状态共享

         1. 第三方数据存储

            将数据存放到数据库、磁盘文件、缓存服务中。

            状态同步的机制：各个子进程向第三方进行定时轮询

         2. 主动通知

            一种改进的方式是当数据发生更新时，主动通知子进程。

4. Cluster 模块

   引入 cluster 模块以解决多核 CPU 的利用率问题，处理进程的健壮性问题。

   1. Cluster 工作原理

      cluster 模块就是 child_process 和 net 模块的组合应用。cluster 启动时，会在内部启动 TCP 服务器，在 cluster.fork()子进程时，将这个 TCP 服务器端 socket 的文件描述符发送给工作进程，如果通过 cluster.fork()复制的，环境变量里存在 NODE_UNIQUE_ID，如果工作进程中存在 listen()侦听网络端口的调用，它将拿到该文件描述符。

      在 cluster 模块应用中，一个主进程只能管理一组工作进程。

   2. Cluster 事件

      - fork：复制一个工作进程后触发该事件
      - online：复制好一个工作进程后，工作进程主动发送一条 online 消息给主进程，主进程收到消息后，触发该事件
      - listening：工作进程中调用 listen()后，发送一条 listening 消息给主进程，主进程收到消息后，触发该事件
      - disconnect：主进程和工作进程之间 IPC 通道断开后会触发该事件
      - exit：有工作进程退出时触发该事件
      - setup：cluster.setupMaster()执行后触发该事件

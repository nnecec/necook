# 5.内存控制

1. V8 的垃圾回收机制与内存限制

   1. Node 与 V8

   2. V8 的内存限制：由于 V8 的管理和分配，Node 使用内存时只能使用部分内存（64 位系统下约为 1.4 GB，32 位系统下约为 0.7 GB）。

   3. V8 的对象分配：所有的 JavaScript 对象都是通过堆来进行分配的。

      声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 V8 的限制。做一次小的垃圾回收需要 50 毫秒以上，做一次非增量式的垃圾回收甚至要 1 秒以上。在用于浏览器的场景下直接限制堆内存是一个好的选择。

      Node 在启动时可以传递--max-old-space-size 或--max-new-space-size 来调整内存限制的大小，一旦生效就不能再动态改变。

   4. V8 的垃圾回收机制

      1. V8 的主要垃圾回收算法

         主要基于分代式垃圾回收机制，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代施以更高效的算法。

         - V8 的内存分代

           在 V8 中，主要将内存分为新生代和老生代两代。V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。--max-old-space-size 用于设置老生代内存空间的最大值，--max-new-space-size 用于设置新生代内存空间。V8 堆内存最大值在 64 位系统上为 1464MB，32 位系统上则为 732MB。

         - Scavenge 算法

           Scavenge 的具体实现中，主要采用了 Cheney 算法。

           Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间中，而非存活对象占用的空间将会被释放。完成复制后，From 空间和 To 空间的角色发生对换。

           Scavenge 是典型的牺牲空间换取时间的算法。缺点是只能使用堆内存的一半，由于只复制存活的对象，且对于生命周期短的场景存活对象只占少部分，所以在时间效率上有优异的表现。适合应用在生命周期较短的新生代中。

           当一个对象经过多次复制依然存活，它将被认为是生命周期较长的对象。这种对象随后会被移动到老生代，采用新的算法管理。这种过程称为晋升。对象晋升主要有两个条件，一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过限制。

           如果一个对象经历过一次 Scavenge 回收，或者要占用超过 25%的 To 空间，则将这个对象晋升到老生代空间中。

         - Mark-Sweep & Mark-Compact

           主要用于在老生代中进行垃圾回收。Mark-Sweep 分为标记和清除两个阶段。Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。

           Mark-Sweep 最大的问题是在一次标记清除回收后，内存空间会出现不连续的状态，会对后续的内存分配造成问题。

           为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 被提出来。Mark-Compact 是标记整理的意思。

           在对象标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

           V8 主要使用 Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才能用 Mark-Compact。

         - Incremental Marking

           为了避免 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的三种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”。

           V8 先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，也就是拆分为许多小“步进”，每做完一“步进”就让 JavaScript 应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。

           V8 后续还引入了延迟清理(lazy sweeping)与增量式整理(incremental compaction)，让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的事件。

   5. 查看垃圾回收日志

      启动时添加`--trace_gc`参数查看垃圾回收日志。

      使用`--prof`，可以得到 V8 执行时的性能分析数据，包含了回收执行时占用的时间，会在目录下的到一个 v8.log 日志文件。使用 linux-tick-processor 工具用于统计日志信息。

2. 高效使用内存

   1. 作用域

      在 JavaScript 中能形成作用域的有：函数调用、with 以及全局作用域。

      函数会在每次被调用时创建对应的作用域，函数执行结束后，该作用域将会销毁。同时作用域中声明的局部变量分配在该作用域上，随作用域的销毁而销毁。这是最基本的内存回收过程

      1. 标识符查找

         与作用域相关的即是标识符查找。所谓标识符，可以理解为变量名。

      2. 作用域链

         沿着作用域链查找变量

      3. 变量的主动释放

         如果是全局变量，需要直到进程退出才能释放，此时将导致引用的对象常驻内存（常驻老生代中）。如果需要释放常驻内存的对象，可以通过`delete`操作来删除引用关系，或将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清楚和整理的过程中，会被回收释放。

   2. 闭包

      实现外部作用域访问内部作用域中变量的方法叫做闭包。这得益于高阶函数的特性：函数可以作为参数活着返回值。

      一旦有变量引用闭包返回的函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。

   3. 小结

      无法立即回收的内存有闭包和全局变量引用这两种情况。会导致老生代中的对象增多。

3. 内存指标

   1. 查看内存使用情况

      `process.memoryUsage()`、`totalmem()`、`freemem()`可以查看内存使用情况。

      1. 查看进程的内存占用

         调用`process.memoryUsage()`，返回：

         rss(resident set size)：进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区(swap)或者文件系统(filesystem)。

         heapTotal 和 heapUsed 对应的是 V8 的堆内存信息。heapTotal 是堆中总共申请的内存量，heapUsed 表示目前堆中使用中的内存量。这三个值的单位都是字节。

      2. 查看系统的内存占用

         os模块中的`totalmem()`和`freemem()`这两个方法用于查看操作系统的内存使用情况，分别返回系统的总内存和闲置内存，以字节为单位。

   2. 堆外内存

      Node 中的内存使用并非都是通过 V8 进行分配的，这些内存称为堆外内存。利用堆外内存可以突破内存限制的问题。

      为何 Buffer 对象并非通过 V8 分配？这在于 Node 并不同于浏览器的应用场景。在浏览器中，JavaScript 直接处理字符串即可满足绝大多数的业务需求，而 Node 则需要处理网络流和文件 I/O 流。

4. 内存泄漏

   造成内存泄漏的原因有如下几个：缓存、队列消费不及时、作用域未释放

   1. 慎将内存当作缓存

      一旦一个对象被当作缓存来使用，就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在扫描和整理时，对这些对象做无用功。

      另一个问题在于，严格意义的缓存有着完善的过期策略，而普通对象的键值对则没有。

      目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态，外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响 Node 进程的性能。在 Node 中主要可以解决以下两个问题：

      1. 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。
      2. 进程之间可以共享缓存。

      主要有 Redis 和 Memcached。

   2. 关注队列状态

      队列在消费者-生产者模型中经常充当中间产物。一旦消费速度低于生产速度，将会形成堆积。

      深度的解决方案是监控队列的长度，一旦堆积，应当通过监控产生报警并通知。另一个解决方案是任意异步调用都用该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。

      对于 Bagpipe 而言，它提供了超时模式和拒绝模式。启用超时模式时，调用加入到队列中就开始计时，超时就直接相应一个超时错误。启用拒绝模式时，当队列拥塞时，新到来的调用会直接相应拥塞错误。

5. 内存泄漏排查

   1. node-heapdump
   2. node-memwatch

6. 大内存应用

   stream 模块用于处理大文件。

   stream 继承自 EventEmitter，具备基本的自定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。无法通过`fs.readFile()`和`fs.writeFile()`直接进行大文件的操作，可改用`fs.createReadStream()`和`fs.createWriteStream()`方法通过流的方式实现对大文件的操作。

   如果不需要进行字符串层面的操作，则不需要借助V8来处理，可以尝试进行纯粹的Buffer操作，这不会收到V8堆内存的限制。但是这种大片使用内存的情况依然要小心，物理内存仍然有限制。

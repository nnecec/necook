# 8.构建 Web 应用

- 无须切换语言环境，部分知识不会因为语言环境的切换而丢失，上下文一致性较好。
- 数据（JSON）可以很好的实现跨前后端直接使用。
- 一些业务（如模版渲染）可以很自由的轻量的选择是在前端还是后端进行，因为编程语言相同，所以切换代价小。

1. 基础功能

   `request`事件发生于网络连接建立，客户端向服务器端发送报文，服务器端解析报文，发现 HTTP 请求的报头时。在已触发`request`事件前，它已准备好`ServerRequest`和`ServerResponse`对象以供对请求和响应报文的操作。

   对于 Web 应用而言，可能有如下需求：

   - 请求方法的判断
   - URL 的路径解析
   - URL 中查询字符串解析
   - Cookie 的解析
   - Basic 认证
   - 表单数据的解析
   - 任意格式文件的上传处理

   1. 请求方法

      GET、POST、HEAD、DELETE、PUT、CONNECT 等方法。请求方法存在于报文的第一行的第一个单词。HTTP_Parser 在解析请求报文的时候，将报文头抽取出来，设置为`req.method`。

   2. 路径解析

      路径部分存在于报文的第一行的第二部分，如下所示

      ```
      GET /path?foo=bar HTTP/1.1
      ```

      HTTP_Parser 将其解析为`req.url`。客户端代理会将 URL 地址解析成报文，将路径和查询部分放在报文第一行。hash 部分会被丢弃。

   3. 查询字符串

      地址栏中路径后的`?foo=bar&baz=val`字符串就是查询字符串，形成请求报文首行的第二部分。

   4. Cookie

      1. 初识 Cookie

         服务器向客户端发送 Cookie，浏览器将 Cookie 保存，之后每次浏览器都会将 Cookie 发向服务器端。

         `Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;`

         `name=value`是必须包含的部分，其余部分皆是可选参数。这些可选参数将会影响浏览器在后续将 Cookie 发送给服务器端的行为。

         - `path`表示这个 Cookie 影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这个 Cookie
         - `Expires`和`Max-Age`用来告知浏览器这个 Cookie 何时过期，如果不设置该选项，在关闭浏览器时会丢失这个 Cookie。`Expires`的值是一个 UTC 格式的时间字符串，告知浏览器此 Cookie 何时将过期，`Max-Age`则告知浏览器此 Cookie 多久后过期。
         - `HttpOnly`告知浏览器不允许通过脚本`document.cookie`去更改这个 Cookie 值
         - `Secure`。当`Secure`为`true`时，在 HTTP 中是无效的，在 HTTPS 中才有效，表示创建的 Cookie 只能在 HTTPS 连接中被浏览器传递到服务器进行会话验证，如果是 HTTP 连接则不会传递该信息。

      2. Cookie 的性能影响

         - 减少 Cookie 的大小
         - 为静态组件使用不同的域名
         - 减少 DNS 查询

   5. Session

      Cookie 可以在前后端修改，为了解决敏感数据的问题，Session 数据只保留在服务器端，客户端无法修改。将每个客户和服务器中的数据一一对应起来常见的两种实现方式

      - 基于 Cookie 来实现用户和数据的映射

        Session 有效期普遍设置为 20 分钟，如果在 20 分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。

        一旦服务器端起用了 Session，将约定一个键值作为 Session 的口令，一旦服务器检查到用户请求 Cookie 中没有携带该值，就会生成一个唯一且不重复的值，并设定超时时间。

        每个请求到来时，检查 Cookie 中的口令与服务器端的数据，如果过期就重新生成，需要在响应给客户端时设置新的值。

      - 通过查询字符串来实现浏览器端和服务器端数据的对应

        原理是检查请求的查询字符串，如果没有值，会生成新的带值的 URL，然后形成跳转，让客户端重新发起请求。

        另外有利用 HTTP 请求头中的 ETag 方法。

      1. Session 与内存

         将 Session 数据直接存在变量 sessions 中，就等于将数据存放在内存中，如果数据量增多，则会引起垃圾回收的频繁扫描，引起性能问题。另一个问题则是我们可能为了利用多核 CPU 而启动多个进程，用户请求的连接将可能随意分配到各个进程中，Node 的进程与进程之间是不能直接共享内存的，用户的 Session 可能会引起错乱。

         为了解决性能问题和 Session 数据无法跨进程共享的问题，常用的方案是将 Session 集中化，将原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。目前常用的工具是 Redis、Memcached 等。

         采用第三方缓存来存储 Session 会引起网络访问的问题。理论上访问网络中的数据要比访问本地磁盘中的数据速度要慢，因为涉及到握手、传输以及网络终端自身的磁盘 I/O 等，但依然采用这些高速缓存的理由：

         - Node 与缓存服务保持长连接，而非短连接，握手导致的延迟只影响初始化。
         - 高速缓存直接在内存中进行数据存储和访问。
         - 缓存服务通常与 Node 进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。

      2. Session 与安全

         口令依然可能被伪造。

         解决方案是将口令通过私钥加密进行签名。

         另一种方案是将客户端的某些独有信息与口令作为原值进行签名。导致口令泄漏的漏洞：

         - XSS 漏洞

           跨站脚本攻击(Cross Site Scripting)，通常都是由网站开发者决定哪些脚本可以执行在浏览器端，形成原因多数是用户的输入没有被转移，而被直接执行。

   6. 缓存

      - 添加`Expires`或`Cache-Control`到报文头中。
      - 配置`ETags`。
      - 让 Ajax 可缓存。

      在普通的 GET 请求报文中，附带 If-Modified-Since 字段，值为数据最后修改时间，如果服务器端没有新的版本则响应 304 状态码。

      时间戳有一定缺陷：

      - 时间戳改动但内容不一定改动
      - 只能精确到秒级别，频繁的内容变更无法生效

      服务端决定生成规则，ETag 的请求和响应是 If-None-Match/ETag。以上两种方法都需要发送一次请求。

      在服务器端在响应内容时，让浏览器明确地将内容缓存起来。

      - 添加`Expires`或`Cache-Control`到报文头中

        Expires 是一个 GMT 格式的时间字符串。为 Cache-Control 设置 max-age 值以倒计时的方式计算过期时间。max-age 会覆盖 Expires。

      - 配置`ETags`

      - 让 Ajax 可缓存

      清除缓存，为文件添加 hash 值。

   7. Basic 认证

      当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。

      如果一个页面需要 Basic 认证，它会检查请求报文头中的 Authorization 字段的内容，该字段的值由认证方式和加密值构成。

      如果用户首次访问该网页，URL 地址中没携带认证内容，那么浏览器会响应一个 401 未授权的状态码。

2. 数据上传

   头部报文能够让服务器端进行大多数业务逻辑操作，但无法携带大量的数据，通过报头的 Transfer-Encoding 或 Content-Length 判断是否带有内容。

   1. 表单数据

      默认的表单提交`Content-Type: application/x-www-form-urlencoded`

   2. 其他格式

      JSON 文件，XML 文件

   3. 附件上传

      `Content-Type: multipart/form-data; boundary=AaB03x`

      `Content-Length: 18231`

      boundary 指定的是每部分内容的分界符，Content-Length 必须确保是报文体的长度。

   4. 数据上传与安全

      1. 内存限制

         在解析表单、JSON 和 XML 部分，采取先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。一旦数据量过大，将发生内存被占光的情况。解决方案：

         - 限制上传内容的大小
         - 通过流式解析，将数据流导向磁盘中，Node 只保留文件路径等小数据

      2. CSRF

         全称 Cross-Site Request Forgery，意为跨站请求伪造，伪装并盗取另一个网站的 Cookie 信息。解决方法为在 Session 中赋予一个随机值，做一次校验去识别该请求是否是伪造的。

3. 路由解析

   1. 文件路径型

      1. 静态文件

         URL 的路径与网站目录的路径一致

      2. 动态文件

         Web 服务器根据 URL 路径找到对应的文件，如 index.asp 或 index.php。

   2. MVC

      主要思想是将业务逻辑按职责分离：控制器(Controller)、模型(Model)和视图(View)。

      最经典的分层模式：

      - 路由解析，根据 URL 寻找到对应的控制器和行为
      - 行为调用相关的模型，进行数据操作
      - 数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端

      1. 手工映射

         手工配置路由

         - 正则匹配
         - 参数解析

      2. 自然映射

   3. RESTful

      全称 REpresentational State Transfer，中文含义为表现层状态转化。

   4. 中间件

      1. 异常处理

         中间件异步产生的异常需要自己传递出来

      2. 中间件与性能

         业务逻辑往往在最后才执行，主要提升的点：

         - 编写高效的中间件

           提升单个处理单元的处理速度，尽早调用 next()执行后续逻辑。常见优化方法：

           - 使用高效的方法。必要时通过 jsperf.com 测试基准性能
           - 缓存需要重复计算的结果
           - 避免不必要的计算。

         - 合理使用路由

   5. 页面渲染

      1. 内容响应

         服务器端响应的报文，最终都要被终端处理。

         1. 内容响应

            1. MIME：Content-Type。不同的文件类型具有不同的 MIME 值
            2. 附件下载：Content-Disposition。客户端会根据它的值判断是应该将报文数据当做即使浏览的内容(inline)还是可下载的附件(attachment)。
            3. 响应 JSON
            4. 响应跳转

         2. 视图渲染

            render()接受参数模版路径和数据，返回 HTML 片段

         3. 模版

            四个要素：模版语言、包含模版语言的模版文件、拥有动态数据的数据对象、模版引擎。

            1. 模版引擎

               语法分解，处理表达式，生成待执行的语句，与数据一起执行生成最终字符串。

            2. with 的应用

            3. 模版逻辑

            4. 集成文件系统

            5. 子模版

            6. 布局视图

            7. 模版性能

               缓存模版文件、缓存模版文件编译后的函数、优化模版中的执行表达式

         4. Bigpipe

            为了解决重数据页面的加载速度问题。解决思路是将页面分割成多个部分，逐步输出填充页面。

            1. 页面布局框架
            2. 持续数据输出
            3. 前端渲染

# 5.内存控制

1. V8的垃圾回收机制与内存限制

   1. Node与V8

   2. V8的内存限制：由于V8的管理和分配，Node使用内存时只能使用部分内存

   3. V8的对象分配：所有的JavaScript对象都是通过堆来进行分配的。声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制。V8做一次小的垃圾回收需要50毫秒以上，做一次非增量式的垃圾回收甚至要1秒以上。在用于浏览器的场景下直接限制堆内存是一个好的选择。在V8初始化时可以调整内存限制的大小。

   4. V8的垃圾回收机制

      1. V8的主要垃圾回收算法

         主要基于分代式垃圾回收机制，现代的垃圾回收算法中按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代施以更高效的算法。

         - V8的内存分代

           在V8中，主要将内存分为新生代和老生代两代。V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。V8堆内存最大值在64位系统上为1464MB，32位系统上则为732MB。

         - Scavenge算法

           Scavenge的具体实现中，主要采用了Cheney算法。Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。

           Scavenge是典型的牺牲空间换取时间的算法。

           当一个对象经过多次复制依然存活，它将被认为是生命周期较长的对象。这种对象随后会被移动到老生代，采用新的算法管理。这种过程称为晋升。对象晋升主要有两个条件，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。

           如果一个对象经历过一次Scavenge回收，或者要占用超过25%的To空间，则将这个对象晋升到老生代空间中。

         - Mark-Sweep & Mark-Compact

           主要用于在老生代中进行垃圾回收。Mark-Sweep分为标记和清除两个阶段。Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。最大的问题是在一次标记清除回收后，内存空间会出现不连续的状态，会对后续的内存分配造成问题。

           Mark-Compact是标记整理的意思。在对象标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

           V8主要使用Mark-Sweep，在空间不足以对从新生代晋升过来的对象进行分配时才能用Mark-Compact。

         - Incremental Marking

           为了避免JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的三种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全停顿”。

           V8先从标记阶段入手，将原本要一口气停顿完成的动作改为增量标记，也就是拆分为许多小“步进”，每做完一“步进”就让JavaScript应用逻辑执行一小会，垃圾回收与应用逻辑交替执行直到标记阶段完成。

           V8后续还引入了延迟清理(lazy sweeping)与增量式整理(incremental compaction)，让清理与整理动作也变成增量式的。

   5. 查看垃圾回收日志

      启动时添加`--trace_gc`参数查看垃圾回收日志。使用`--prof`，可以得到V8执行时的性能分析数据，包含了回收执行时占用的时间，会在目录下的到一个v8.log日志文件。使用linux-tick-processor工具用于统计日志信息。

2. 高效使用内存

   1. 作用域

      在JavaScript中能形成作用域的有函数调用、with以及全局作用域。

      最基本的内存回收过程

      1. 标识符查找

         与作用域相关的即是标识符查找。所谓标识符，可以理解为变量名。

      2. 作用域链

         沿着作用域链查找变量

      3. 变量的主动释放

         如果是全局变量，需要直到进程推出才能释放，此时将导致引用的对象常驻内存（老生代）。如果需要释放常驻内存的对象，可以通过`delete`操作来删除引用关系，或将变量重新复制，让旧的对象脱离引用关系。在接下来的老生代内存清楚和整理的过程中，会被回收释放。

   2. 闭包

      实现外部作用域访问内部作用域中变量的方法叫做闭包。这得益于高阶函数的特性：函数可以作为参数活着返回值。

      一旦有变量引用闭包返回的函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。

   3. 小结

      无法立即回收的内存有闭包和全局变量引用这两种情况。会导致老生代中的对象增多。

3. 内存指标

   1. 查看内存使用情况

      `process.memoryUsage()`、`totalmem()`、`freemem()`可以查看内存使用情况。

      1. 查看进程的内存占用

         调用`process.memoryUsage()`，返回：

         rss(resident set size)：进程的常驻内存部分。进程的内存总共有几部分，一部分是rss，其余部分在交换区(swap)或者文件系统(filesystem)。

         heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内存量，heapUsed表示目前堆中使用中的内存量。这三个值的单位都是字节。

      2. 查看系统的内存占用

         totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，分别返回系统的总内存和闲置内存，以字节为单位。

   2. 堆外内存

      Node中的内存使用并非都是通过V8进行分配的，这些内存称为堆外内存。利用堆外内存可以突破内存限制的问题。

      为何Buffer对象并非通过V8分配？这在于Node并不同于浏览器的应用场景。在浏览器中，JavaScript直接处理字符串即可满足绝大多数的业务需求，而Node则需要处理网络流和文件I/O流。

4. 内存泄漏

   造成内存泄漏的原因有如下几个：缓存、队列消费不及时、作用域未释放

   1. 慎将内存当作缓存

      一旦一个对象被当作缓存来使用，就意味着它将会常驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在扫描和整理时，对这些对象做无用功。

      另一个问题在于，严格意义的缓存有着完善的过期策略，而普通对象的键值对则没有。

      目前比较好的解决方案是采用进程外的缓存，进程自身不存储状态，外部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。在Node中主要可以解决一下两个问题：

      1. 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。
      2. 进程之间可以共享缓存。

   2. 关注队列状态

      深度的解决方案是监控队列的长度，一旦堆积，应当通过监控产生报警并通知。另一个解决方案是任意异步调用都用该包含超时机制，一旦在限定的时间内未完成响应，通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个下限值。

      对于Bagpipe而言，它提供了超时模式和拒绝模式。

5. 内存泄漏排查

   1. node-heapdump
   2. node-memwatch

6. 大内存应用

   stream模块用于处理大文件。

   stream继承自EventEmitter，具备基本的自定义时间功能，同时抽象出标准的事件和方法。它分可读和可写两种。无法通过`fs.readFile()`和`fs.writeFile()`直接进行大文件的操作，可改用`fs.createReadStream()`和`fs.createWriteStream()`方法通过流的方式实现对大文件的操作。


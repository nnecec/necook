#  异步编程

1. 函数式编程

   1. 高阶函数

      高阶函数可以把函数作为参数，或是将函数作为返回值的函数，形成一种后续传递风格的结果接收方式，而非单一的返回值形式。

   2. 偏函数用法

      偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法。

2. 异步编程的优势与难点

   1. 优势

      Node带来的最大特性莫过于基于事件驱动的非阻塞I/O模型。

   2. 难点

      - 异常处理：try/catch对异步方法不会发挥作用。Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值贼表明异步调用没有异常抛出。

        自行编写的异步方法上，也需要去遵循这样一些原则：

        必须执行调用者传入的回调函数。

        正确传递回异常供调用者判断。

      - 函数嵌套过深

      - 阻塞代码：没有线程沉睡功能，调用setTimeout()效果会更好。

      - 多线程编程

      - 异步转同步

3. 异步编程解决方案

   1. 事件发布／订阅模式
      - 继承events模块
      - 利用事件队列解决雪崩问题
      - 多异步之间的协作方案

   2. Promise／Deferred模式

      1. Promises/A

         - Promise操作只会处在3种状态的一种：未完成态、完成态和失败态
         - Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。
         - Promise的状态一旦转化，将不能被更改。

         对`then()`的要求

         - 接受完成态、错误态的回调方法。
         - 可选地支持progress事件回调作为第三个方法。
         - `then()`方法只接受function对象
         - `then()`方法继续返回Promise对象

      2. Promise中的多异步协作

      3. Promise的进阶知识

         - 支持序列执行的Promise

           要让Promise支持链式执行：

           1. 将所有回调都存到队列中。
           2. Promise完成时，逐个执行回调，一旦检测到返回了新的Promise对象，停止执行，然后将当前Deferred对象的promise引用改变为新的Promise

         - 将API Promise化

   3. 流程控制库

      1. 尾触发与Next：Connect的核心实现
      2. async：
         1. 异步的串行执行：series()方法实现一组任务的串行执行
         2. 异步的并行执行：parallel()方法用以并行执行一些异步操作
         3. 异步调用的依赖处理：series()适合无依赖的异步串行执行，waterfall()可以满足
         4. 自动依赖处理：auto()实现复杂业务处理
      3. Step：所有的任务都将会串行依次执行
         - 并行任务执行：parallel()
         - 结果分组：group()
      4. wind：
         - 异步任务定义：利用`eval()`访问上下文的特性
         - $await()与任务模型：表示等待任务结束后才会执行后续操作
         - 异步方法转换辅助函数：将异步方法任务化

   4. 异步并发控制

      1. bagpipe的解决方案

         - 通过一个队列来控制并发量
         - 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行
         - 如果活跃调用达到限定值，调用暂时存放在队列中
         - 每个异步调用结束时，从队列中取出新的异步调用执行

      2. async的解决方案

         parallelLimit()：用于处理异步调用的限制

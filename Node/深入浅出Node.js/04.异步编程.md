# 异步编程

1. 函数式编程

   1. 高阶函数

      高阶函数可以把函数作为参数，或是将函数作为返回值的函数，形成一种后续传递风格的结果接收方式，而非单一的返回值形式。后续传递风格的程序编写将函数的业务重点从返回值传递到了回调函数中。

   2. 偏函数用法

      偏函数用法是指创建一个调用另外一个部分（参数或变量已经预置的函数）的函数的用法。

2. 异步编程的优势与难点

   1. 优势

      Node 带来的最大特性莫过于基于事件驱动的非阻塞 I/O 模型。非阻塞 I/O 可以使 CPU 与 I/O 不相互依赖等待。

      利用事件循环的方式，JavaScript 线程像一个分配任务和处理结果的大管家，I/O 线程池里的各个 I/O 线程都是小二。这个模型的缺点在于管家无法承担过多的细节性任务，如果承担太多，则会印象到任务的调度。

   2. 难点

      - 异常处理：try/catch 对异步方法不会发挥作用。比如 callback 在下个 Tick 中才会被执行导致无法 catch callback 执行中的错误。

        所以 Node 在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出。

        自行编写的异步方法上，也需要去遵循这样一些原则：

        1. 必须执行调用者传入的回调函数。
        2. 正确传递回异常供调用者判断。

      - 函数嵌套过深

      - 阻塞代码：没有线程沉睡功能，调用 setTimeout()效果会更好。

      - 多线程编程

        Node 借鉴 Web Workers 的模式，`child_process` 是其基础 API，`cluster` 模式是更深层次的引用。

      - 异步转同步

3. 异步编程解决方案

   1. 事件发布／订阅模式

      具有`addListener/on()`、`once()`、`removeListener()`、`removeAllListeners()`֖ 和`emit()`等基本的事件监听模式。

      Node 对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的：

      - 如果对一个事件添加了超过 10 个侦听器，将会得到一条警告。
      - 为了处理异常，EventEmitter 对象对 error 事件进行了特殊对待。如果运行期间的错误触发了 error 事件，EventEmitter 会检查是否有对 error 事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。

      1. 继承 events 模块
      2. 利用事件队列解决雪崩问题
      3. 多异步之间的协作方案：使用哨兵变量解决多对一的订阅问题

   2. Promise／Deferred 模式

      1. Promises/A

         - Promise 操作只会处在 3 种状态的一种：未完成态、完成态和失败态
         - Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。
         - Promise 的状态一旦转化，将不能被更改。

         对`then()`的要求

         - 接受完成态、错误态的回调方法。
         - 可选地支持 progress 事件回调作为第三个方法。
         - `then()`方法只接受 function 对象
         - `then()`方法继续返回 Promise 对象

      2. Promise 中的多异步协作：Promise.all()

      3. Promise 的进阶知识

         - 支持序列执行的 Promise

           要让 Promise 支持链式执行：

           1. 将所有回调都存到队列中。
           2. Promise 完成时，逐个执行回调，一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise

         - 将 API Promise 化

   3. 流程控制库

      1. 尾触发与 Next：中间件 Connect 的核心实现
      2. async：
         1. 异步的串行执行：series()方法实现一组任务的串行执行
         2. 异步的并行执行：parallel()方法用以并行执行一些异步操作
         3. 异步调用的依赖处理：series()适合无依赖的异步串行执行，waterfall()可以满足
         4. 自动依赖处理：auto()实现复杂业务处理
      3. Step：所有的任务都将会串行依次执行
         - 并行任务执行：parallel()
         - 结果分组：group()
      4. wind：
         - 异步任务定义：利用`eval()`访问上下文的特性
         - \$await()与任务模型：表示等待任务结束后才会执行后续操作
         - 异步方法转换辅助函数：将异步方法任务化

   4. 异步并发控制

      如果并发量过大，下层服务器可能会因为大量并发调用出现故障。仍需要做一定的过载保护。

      1. bagpipe 的解决方案

         - 通过一个队列来控制并发量
         - 如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行
         - 如果活跃调用达到限定值，调用暂时存放在队列中
         - 每个异步调用结束时，从队列中取出新的异步调用执行

      2. async 的解决方案

         parallelLimit()：用于处理异步调用的限制

# 7.网络编程

Node是一个面向网络而生的平台，它具有事件驱动、无阻塞、单线程等特性。

1. 构建TCP服务

   1. TCP

      TCP全名为传输控制协议，在OSI模型（由七层组成，分别为物理层、数据链结层、网络层、传输层、会话层、表示层、应用层）中属于传输层协议。许多应用层协议基于TCP构建，典型的是HTTP、SMTP、IMAP等协议。

      TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话。客户端请求连接，服务器端响应，客户端开始传输。

   2. 创建TCP服务器端

      net.createServer(listener)

   3. TCP服务的事件

      代码分为服务器事件和连接事件

      1. 服务器事件

         通过`net.createServer()`创建的服务器而言，它是一个EventEmitter实例，它的自定义事件有如下几种：

         - listening：在调用`server.listen()`绑定端口或者Domain Socket后触发
         - connection：每个客户端套接字连接到服务器端时触发，简洁写法为通过`net.createServer()`，最后一个参数传递。
         - close：当服务器关闭时触发，在调用`server.close()`后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有链接都断开后，会触发该事件。
         - error：当服务器发生异常时，将会触发该事件。

      2. 连接事件

         服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可写可读Stream对象。Stream对象可以用于服务器端和客户端之间的通信。它具有如下自定义事件：

         - data：当一端调用`write()`发送数据时，另一端会触发data事件，事件传递的数据即是`write()`发送的数据。

         - end：当连接中的任意一端发送了FIN数据时，将会触发该事件。

         - connect：该事件用于客户端，当套接字与服务器端连接成功时会被触发。

         - drain：当任意一端调用`write()`发送数据时，当前这端会触发该事件。

         - error：当异常发生时，触发该事件。

         - close：当套接字完全关闭时，触发该事件。

         - timeout：当一定时间后连接不在活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了。

           由于TCP套接字是可写可读的Stream对象，可以利用`pipe()`方法巧妙地实现管道操作。

           TCP针对网络中的小数据包有一定的优化策略：Nagle算法。要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小数据包将会被Nagle算法合并。

2. 构建UDP服务

   UDP又称用户数据包协议，与TCP一样同属于网络传输层。TCP中连接一旦建立，所有的会话都基于连接完成，客户端如果要与另一个TCP服务通信，需要另创建一个套接字来完成连接。但在UDP中，一个套接字可以与多个UDP服务通信，它虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但由于它无需连接，资源消耗低，处理快速且灵活，所以常常应用在偶尔丢一两个数据包也不会产生重大影响的场景。

   1. 创建UDP套接字

      UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据。

   2. 创建UDP服务器端

      若想让UDP套接字接收网络消息，只要调用`dgram.bind(port, [address])`方法对网卡和端口进行绑定即可。

   3. 创建UDP客户端

   4. UDP套接字事件

      UDP套接字是EventEmitter的实例

      - message：当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为消息Buffer对象和一个远程地址信息。
      - listening：当UDP套接字开始侦听时触发该事件。
      - close：调用`close()`方法时触发该事件，并不再触发`message`事件。如需再次触发`message`事件，重新绑定即可。
      - error：当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程推出。

3. 构建HTTP服务

   1. HTTP

      1. 初识HTTP

         HTTP全称是超文本传输协议，HTTP构建在TCP之上，属于应用层协议。在HTTP的两端是服务器和浏览器，即著名的B/S模式。

      2. HTTP报文

         在启动上述服务器端代码后，我们对经典示例代码进行一次报文的获取。

         网络通信的报文信息分为几个部分：第一部分内容为经典的TCP的3次握手过程；第二部分是在完成握手之后，客户端向服务器端发送请求报文；第三部分是服务器端完成处理后，向客户端发送响应内容，包括响应头和响应体；最后部分是结束会话的信息。

         从上述的报文信息中可以看出HTTP的特点，它是基于请求响应式的。报文内容都包括两个部分：报文头和报文体。

   2. http模块

      在Node中，HTTP服务继承自TCP服务器（net模块），它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型的区别是，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的过程进行了封装。

      1. HTTP请求

         对于TCP连接的读操作，http模块将其封装为ServerRequest对象。

      2. HTTP响应

         `res.setHeader()`和`res.writeHead()`，报头在报文体发送前发送的。无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用`res.end()`结束请求。

      3. HTTP服务的事件

         服务器也是一个EventEmitter实例

         - connection事件：在开始HTTP请求和响应前，客户端与服务端需要建立底层的TCP连接，这个链接可能因为开启了keep-alive，可以在多次请求响应之间使用；当这个连接建立时，服务器触发一次connection事件。
         - request事件：建立TCP连接后，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件；在`res.end()`后，TCP连接可能将用于下一次请求响应。
         - close事件：与TCP服务器的行为一致，调用`server.close()`方法停止接受新的连接，当已有的连接都断开时，触发该事件；可以给`server.close()`传递一个回调函数来快速注册该事件。
         - checkContinue事件：某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带`Expect: 100-continue`的请求到服务器，服务器将会触发checkContinue事件。
         - connect事件：当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现；如果不监听该事件，发起该请求的连接将会关闭。
         - upgrade事件：当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。如果不监听该事件，发起该请求的连接将会关闭。
         - clientError事件：连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件。

   3. HTTP客户端
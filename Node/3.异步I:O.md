# 3.异步I/O

1. 为什么要异步I/O

   1. 用户体验

      请求资源的时间；数据分布到多台服务器上，分布式将成为常态。I/O是昂贵的，分布式I/O是更昂贵的。

   2. 资源分配

      完成互不相关任务的主流方法：

      - 单线程串行依次执行：会因阻塞I/O导致硬件资源得不到更优使用
      - 多线程并行完成：死锁、状态同步等问题

      Node：利用单线程，远离多线程死锁、状态同步等问题；利用异步I/O，让单线程远离阻塞。

      为了弥补单线程无法利用多核CPU的缺点，Node提供了类似Web Workers的子进程。

2. 异步I/O实现现状

   1. 异步I/O与非阻塞I/O

      操作系统将所有输入输出设备抽象为文件，阻塞I/O完成整个获取数据的过程，非阻塞I/O则不带数据直接返回，要获取数据，还需要通过文件描述符再次读取。

      为了获取完整的数据，应用程序需要重复调用I/O操作来确认是否完成。这种技术叫做轮询。

      - read。最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。
      - select。通过文件描述符上的事件状态来判断。由于采用一个1024长度的数组来存储状态，最多可以同时检查1024个文件描述符。
      - poll。采用链表的方式避免数组长度的限制，能避免不必要的检查。文件描述符较多的时候，性能十分低下。
      - epoll。该方案事Linux下效率最高的I/O事件通知机制。在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件将它唤醒。它真实利用了事件通知、执行回调的方式，而不是遍历查询。

   2. 理想的非阻塞异步I/O

      应用程序发起非阻塞调用，无需通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序。

   3. 现实的异步I/O

      让部分线程进行阻塞I/O或者非阻塞I/O加轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进行传递。

      Windows下IOCP的异步I/O模型。

      Node的单线程仅仅只是JavaScript执行在单线程中。无论在*nix还是Windows平台，内部完成I/O任务的另有线程池。

3. Node的异步I/O

   1. 事件循环

      Node自身的执行模型——事件循环。

      启动进程时，Node便会创建一个类似于`while(true)`的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理。

   2. 观察者

      Tick的过程中，由观察者判断是否有事件需要处理。每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是想这些观察者询问是否有要处理的事件。


# 基本认证机制

HTTP 提供了一个原生的质询 / 响应（challenge/response）框架，简化了对用户的认证过程。

Web 应用程序收到一条 HTTP 请求报文时，服务器没有按照请求执行动作，而是以一个“认证质询”进行响应，要求用户提供一些保密信息来说明他是谁，从而对其进行质询。

用户再次发起请求时，要附上保密证书（用户名和密码）。如果证书不匹配，服务器可以再次质询客户端，或产生一条错误信息。如果证书匹配，就可以正常完成请求了。

HTTP 定义了两个官方的认证协议：基本认证和摘要认证。

认证协议与首部：

步骤| 首部 | 描述 | 方法/状态
-|-|-|-
 请求 | | 第一条请求没有认证信息 | GET
 质询 | WWW-Authenticate | 服务器用 401 状态拒绝了请求，说明需要用户提供用户名和密码。服务器上可能会分为不同的区域，每个区域都有自己的密码，所以服务器会在 WWW-Authenticate 首部对保护区域进行描述。同样，认证算法也是在 WWW-Authenticate  首部中指定的| 401 Unauthorized
 授权 | Authorization | 客户端重新发出请求，但这一次会附加一个 Authorization  首部，用来说明认证算法、用户名和密码| GET
 成功 | Authentication-Info | 如果授权证书是正确的，服务器就会将文档返回。有些授权算法会在可选的 Authentication-Info  首部返回一些与授权会话相关的附加信息 | 200 OK

## 基本认证

在基本认证中，Web 服务器可以拒绝一个事务，质询客户端，请用户提供有效的用户名和密码。服务器会返回 401 状态码，而不是 200 状态码来初始化认证质询，并用 WWW-Authenticate 响应首部指定要访问的安全域。浏览器收到质询时，会打开一个对话框，请求用户输入这个域的用户名和密码。然后将用户名和密码稍加扰码，再用 Authorization 请求首部回送给服务器。

质询/响应 | 首部语法及描述
-|-
质询（服务器发往客户端） | 网站的不同部分可能有不同的密码。域就是一个引用字符串，用来命名所请求的文档集，这样用户就知道该使用哪个密码了：WWW-Authenticate: Basic realm=quoted-realm
响应（客户端发往服务器） | 用冒号（：）将用户名和密码连接起来，然后转换成 Base-64 编码，这样在用户名和密码中包含国际字符会稍微容易一些，也能尽量避免通过观察网络流量并只进行一些粗略的检查就可以获取用户名和密码情况的发生：Authorization: Basic base64-username-and-password

通过代理服务器提供对某组织内部资源的统一访问控制是一种很便捷的方式。这个过程的第一步就是通过代理认证（proxy authentication）来识别身份。

Web服务器 | 代理服务器
-|-
Unauthorized status code: 401 | Unauthorized status code: 407
WWW-Authenticate | Proxy-Authenticate
Authorization | Proxy-Authorization
Authentication-Info | Proxy-Authentication-Info

基本认证的安全缺陷：

1. 基本认证会通过网络发送用户名和密码，这些用户名和密码都是以一种很容易解码的形式表示的。
2. 即使密码是以更难解码的方式加密的，第三方用户仍然可以捕获被修改过的用户名和密码，并将修改过的用户名和密码一次一次地重放给原始服务器，以获得对服务器的访问权。
3. 即使将基本认证用于一些不太重要的应用程序，比如公司内部网络的访问控制或个性化内容的访问，一些不良习惯也会让它变得很危险。
4. 基本认证没有提供任何针对代理和作为中间人的中间节点的防护措施，它们没有修改认证首部，但却修改了报文的其余部分，这样就严重地改变了事务的本质。
5. 假冒服务器很容易骗过基本认证。
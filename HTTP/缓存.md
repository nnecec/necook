# 缓存

当 Web 请求抵达缓存时，如果本地有“已缓存的”副本，就可以从本地存储设备而不是原始服务器中提取这个文档。使用缓存有下列优点：

- 缓存减少了冗余的数据传输，节省网络费用。
- 缓存缓解了网络瓶颈的问题。更快地加载页面。
- 缓存降低了对原始服务器的要求。服务器可以更快地响应，避免过载的出现。
- 缓存降低了距离时延，因为从较远的地方加载页面会更慢一些。

## 命中的和未命中的

可以用已有的副本为某些到达缓存的请求提供服务。这被称为缓存命中（cache hit）。其他一些到达缓存的请求可能会由于没有副本可用，而被转发 给原始服务器。这被称为缓存未命中（cache miss）。

- 再验证
    原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看它们保存的副本是否仍是服务器上最新的副本。这些“新鲜度检测”被称为 HTTP 再验证（revalidation）。
    缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的 `304 Not Modified` 进行响应。只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端。这被称作再验证命中（revalidate hit）或缓慢命中（slow hit）。
- 命中率
    由缓存提供服务的请求所占的比例被称为缓存命中率（cache hit rate，或称为缓存命中比例），有时也被称为文档命中率（document hit rate）。
- 字节命中率
- 区分命中和未命中的情况
    通过 Date 首部区分来自缓存还是服务器

## 缓存的拓扑结构

- 私有缓存
- 公有代理缓存
- 代理缓存的层次结构
    在较小缓存中未命中的请求会被导向较大的父缓存（parent cache）。其基本思想是在靠近客户端的地方使用小型廉价缓存，而更高层次中，则逐步采用更大、功能更强的缓存来装载多用户共享的文档。
- 网状缓存、内容路由以及对等缓存
    网状缓存中的代理缓存之间会以更加复杂的方式进行对话，做出动态的缓存通信决策，决定与哪个父缓存进行对话，或者决定彻底绕开缓存，直接连接原始服务器。这种代理缓存会决定选择何种路由对内容进行访问、管理和传送，因此可将其称为内容路由器（content router）。
    网状缓存中为内容路由设计的缓存（除了其他任务之外）要完成下列所有功能。

      - 根据 URL 在父缓存或原始服务器之间进行动态选择。
      - 根据 URL 动态地选择一个特定的父缓存。
      - 前往父缓存之前，在本地缓存中搜索已缓存的副本。
      - 允许其他缓存对其缓存的部分内容进行访问，但不允许因特网流量通过它们的缓存。

## 缓存的处理步骤

1. 接收——缓存从网络中读取抵达的请求报文。
2. 解析——缓存对报文进行解析，提取出 URL 和各种首部。
3. 查询——缓存查看是否有本地副本可用，如果没有，就获取一份副本（并将其保存在本地）。
4. 新鲜度检测——缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。
5. 创建响应——缓存会用新的首部和已缓存的主体来构建一条响应报文。
6. 发送——缓存通过网络将响应发回给客户端。
7. 日志——缓存可选地创建一个日志文件条目来描述这个事务。

## 验证副本是否过期

参考[浏览器缓存机制剖析](./浏览器缓存机制剖析.md)

过期响应首部

### 强弱验证器

实体标签和最近修改日期都是缓存验证器（cache validator）。
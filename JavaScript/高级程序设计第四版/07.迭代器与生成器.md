# 迭代器与生成器

“迭代”的意思是按照顺序反复多次执行一段程序， 通常会有明确的终止条件。ECMAScript 6 规范新增了两个高级特性： 迭代器和生成器。

循环是迭代机制的基础，这是因为它可以指定迭代的次数，以及 每次迭代要执行什么操作。每次循环都会在下一次迭代开始之前完 成，而每次迭代的顺序都是事先定义好的。

迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有 项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定 义。）数组是 JavaScript 中有序集合的最典型例子。

由于如下原因，通过这种循环来执行例程并不理想。

- 迭代之前需要事先知道如何使用数据结构。
- 遍历顺序并不是数据结构固有的。

## 迭代器模式

迭代器模式（特别是在 ECMAScript 这个语境下）描述了一个方 案，即可以把有些结构称为“可迭代对象”（iterable），因为它们实现 了正式的 Iterable 接口，而且可以通过迭代器 Iterator 消费。

可迭代对象是一种抽象的说法。基本上，可以把可迭代对象理解 成数组或集合这样的集合类型的对象。它们包含的元素都是有限的， 而且都具有无歧义的遍历顺序

任何实现 Iterable 接口的数据结构都可以被实现 Iterator 接口的结构“消费”（consume）。迭代器（iterator）是按需创建的一次 性对象。每个迭代器都会关联一个可迭代对象，而迭代器会暴露迭代 其关联可迭代对象的 API。迭代器无须了解与其关联的可迭代对象的 结构，只需要知道如何取得连续的值。这种概念上的分离正是 Iterable 和 Iterator 的强大之处。

### 可迭代协议

很多内置类型都实现了 Iterable 接口：

- 字符串
- 数组
- 映射
- 集合
- arguments 对象
- NodeList 等 DOM 集合类型

通过 instance[Symbol.iterator] 检查是否存在默认迭代器属性。

- 接收可迭代对象的原生语言特性包括：
- for-of 循环
- 数组解构 扩展操作符
- Array.from()
- 创建集合 创建映射
- Promise.all() 接收由期约组成的可迭代对象
- Promise.race() 接收由期约组成的可迭代对象
- yield\* 操作符，在生成器中使用

如果对象原型链上的父类实现了 Iterable 接口，那这个对象 也就实现了这个接口

### 迭代器协议

迭代器是一种一次性使用的对象，用于迭代与其关联的可迭代对 象。迭代器 API 使用 next() 方法在可迭代对象中遍历数据。每次成 功调用 next() ，都会返回一个 IteratorResult 对象，其中包 含迭代器返回的下一个值。若不调用 next() ，则无法知道迭代器的 当前位置。

### 自定义迭代器

与 Iterable 接口类似，任何实现 Iterator 接口的对象都可 以作为迭代器使用。

每个以这种方式创建的迭代器也实现了 Iterable 接口。 Symbol.iterator 属性引用的工厂函数会返回相同的迭代器

因为每个迭代器也实现了 Iterable 接口，所以它们可以用在 任何期待可迭代对象的地方，比如 for-of 循环

### 提前终止迭代器

- for-of 循环通过 break 、 continue 、 return 或 throw 提前退出；
- 解构操作并未消费所有值。

如果迭代器没有关闭，则还可以继续从上次离开的地方继续迭 代。。比如，数组的迭代器就是不能关闭的。

```js
let a = [1, 2, 3, 4, 5];
let iter = a[Symbol.iterator]();

for (let i of iter) {
  console.log(i);
  if (i > 2) {
    break;
  }
} // 1 // 2 // 3

for (let i of iter) {
  console.log(i);
} // 4 // 5
```

因为 return() 方法是可选的，所以并非所有迭代器都是可关 闭的。要知道某个迭代器是否可关闭，可以测试这个迭代器实例的 return 属性是不是函数对象。不过，仅仅给一个不可关闭的迭代器 增加这个方法并不能让它变成可关闭的。这是因为调用 return() 不会强制迭代器进入关闭状态。即便如此， return() 方法还是会 被调用。

## 生成器

```js
// 生成器函数声明
function* generatorFn() {}

// 生成器函数表达式
let generatorFn = function* () {};

// 作为对象字面量方法的生成器函数
let foo = { *generatorFn() {} };

// 作为类实例方法的生成器函数
class Foo {
  *generatorFn() {}
}

// 作为类静态方法的生成器函数
class Bar {
  static *generatorFn() {}
}
```

箭头函数不能用来定义生成器函数。

调用生成器函数会产生一个生成器对象。生成器对象一开始处于 暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现 了 Iterator 接口，因此具有 next() 方法。调用这个方法会让生 成器开始或恢复执行。

next() 方法的返回值类似于迭代器，有一个 done 属性和一 个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next() 就会让生成器到达 done: true 状态。

生成器对象实现了 Iterable 接口，它们默认的迭代器是自引 用的

yield 关键字可以让生成器停止和开始执行，也是生成器最有 用的地方。生成器函数在遇到 yield 关键字之前会正常执行。遇到 这个关键字后，执行会停止，函数作用域的状态会被保留。停止执行 的生成器函数只能通过在生成器对象上调用 next() 方法来恢复执 行

生成器函数内部的执行流程会针对每个生成器对象区分作用域。 在一个生成器对象上调用 next() 不会影响其他生成器。

1. 生成器对象作为可迭代对象
2. 使用 yield 实现输入和输出
3. 产生可迭代对象。可以使用星号增强 yield 的行为，让它能够迭代一个可迭代对 象，从而一次产出一个值
4. 使用 yield* 实现递归算法 yield* 最有用的地方是实现递归操作，此时生成器可以产生自 身。

### 生成器作为默认迭代器

因为生成器对象实现了 Iterable 接口，而且生成器函数和默 认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭 代器。

### 提前终止生成器

与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next() 方法，还有一个可选的 return() 方法用于提前终止迭代器。生成器对象除了有这两个方 法，还有第三个方法： throw() 。

throw() 方法会在暂停的时候将一个提供的错误注入到生成器 对象中。如果错误未被处理，生成器就会关闭。假如生成器函数内部处理了这个错误，那么生成器就不会 关闭，而且还可以恢复执行。错误处理会跳过对应的 yield ， 因此在这个例子中会跳过一个值。
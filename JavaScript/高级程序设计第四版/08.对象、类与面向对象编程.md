# 对象、类与面向对象编程

## 理解对象

ECMA-262 使用一些内部特性来描述属性的特征。这些特性是由 为 JavaScript 实现引擎的规范定义的。因此，开发者不能在 JavaScript 中 直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个 中括号把特性的名称括起来，比如 [[Enumerable]] 。

属性分两种：数据属性和访问器属性。

1. 数据属性

   数据属性包含一个保存数据值的位置。值会从这个位置读取，也 会写入到这个位置。数据属性有 4 个特性描述它们的行为。

   - [[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为访问器属性。默认情况下，所有直接定义在对象上的 属性的这个特性都是 true ，如前面的例子所示。
   - [[Enumberable]] ：表示属性是否可以通过 for-in 循 环返回。默认情况下，所有直接定义在对象上的属性的这个 特性都是 true ，如前面的例子所示。
   - [[Writable]] ：表示属性的值是否可以被修改。默认情 况下，所有直接定义在对象上的属性的这个特性都是 true ，如前面的例子所示。
   - [[Value]] ：包含属性实际的值。这就是前面提到的那个 读取和写入属性值的位置。这个特性的默认值为 undefined 。

2. 访问器属性

   访问器属性不包含数据值。相反，它们包含一个获取（getter）函 数和一个设置（setter）函数，不过这两个函数不是必需的。在读 取访问器属性时，会调用获取函数，这个函数的责任就是返回一 个有效的值。在写入访问器属性时，会调用设置函数并传入新 值，这个函数必须决定对数据做出什么修改。访问器属性有 4 个特 性描述它们的行为。

   - [[Configurable]] ：表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特性，以及是否可以把 它改为数据属性。默认情况下，所有直接定义在对象上的属 性的这个特性都是 true 。
   - [[Enumerable]] ：表示属性是否可以通过 for-in 循 环返回。默认情况下，所有直接定义在对象上的属性的这个 特性都是 true 。
   - [[Get]] ：获取函数，在读取属性时调用。默认值为 undefined 。
   - [[Set]] ：设置函数，在写入属性时调用。默认值为 undefined 。

Object.defineProperty() Object.defineProperties() Object.getOwnPropertyDescriptor() Object.getOwnPropertyDescriptors()

Object.assign()

这个方法接收一个目标对象和一个或多个源对象作为参数，然后 将每个源对象中可枚举（ Object.propertyIsEnumerable() 返 回 true ）和自有（ Object.hasOwnProperty() 返回 true ） 属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个 符合条件的属性，这个方法会使用源对象上的 [[Get]] 取得属性的 值，然后使用目标对象上的 [[Set]] 设置属性的值。
不能回滚。

Object.is(a, b)

### 增强的对象语法

1. 属性值简写
2. 可计算属性 不能回滚
3. 简写方法名

### 对象解构

解构在内部使用函数 ToObject() （不能在运行时环境中直接 访问）把源数据结构转换为对象。这意味着在对象解构的上下文中， 原始值会被当成对象。

## 创建对象

工厂模式 构造函数模式 原型模式

### 工厂模式

这种工厂模式 虽然可以解决创建多个类似对象的问题，但没有解决对象标识问题

```js
function createPerson(name, age, job) {
  let o = new Object();
  o.name = name;
  o.age = age;
  o.sayName = function () {
    console.log(this.name);
  };
  return o;
}
let person1 = createPerson('Nicholas', 29);
```

### 构造函数模式

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.sayName = function () {
    console.log(this.name);
  };
}

let person1 = new Person('Nicholas', 29);
```

要创建 Person 的实例，应使用 new 操作符。以这种方式调用 构造函数会执行如下操作。

1. 在内存中创建一个新对象。
2. 这个新对象内部的 [[Prototype]] 特性被赋值为构造函数 的 prototype 属性。
3. 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。
4. 执行构造函数内部的代码（给新对象添加属性）。
5. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创 建的新对象。

定义自定义构造函数可以确保实例被标识为特定类型，相比于工 厂模式，这是一个很大的好处。

构造函数虽然有用，但也不是没有问题。构造函数的主要问题在 于，其定义的方法会在每个实例上都创建一遍。

### 原型模式

每个函数都会创建一个 prototype 属性，这个属性是一个对 象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这 个对象就是通过调用构造函数创建的对象的原型。

使用原型对象的好处是，在它上面定义的属性和方法可以被对象实例共享。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型

### 理解原型

只要创建一个函数，就会按照特定的规则为这个函数 创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。

**proto**属性关键在于：实例与构造函数原型之间有直接的联系，但实例与 构造函数之间没有。

Super.prototype.isPrototypeOf(sub)

Object.setPrototypeOf(instance, newprototype)

为避免使用 Object.setPrototypeOf() 可能造成的性能下 降，可以通过 Object.create() 来创建一个新对象

Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的\_\_proto\_\_。

### 原型层级

在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索 开始于对象实例本身。如果在这个实例上发现了给定的名称，则 返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指 针进入原型对象，然后在原型对象上找到属性后，再返回对应的值。

只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原 型对象上的同名属性，也就是虽然不会修改它，但会屏蔽对它的 访问。即使在实例上把这个属性设置为 null ，也不会恢复它和 原型的联系。不过，使用 delete 操作符可以完全删除实例上的 这个属性，从而让标识符解析过程能够继续搜索原型对象。

通过 hasOwnProperty() 方法检测某个属性是否在实例上。

in 操作符同时检测实例及原型

for-in 循环、 Object.keys() 、 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 以及 Object.assign() 在属性枚举顺序方面有很大区别。 forin 循环和 Object.keys() 的枚举顺序是不确定的，取决于 JavaScript 引擎，可能因浏览器而异。 Object.getOwnPropertyNames() 、 Object.getOwnPropertySymbols() 和 Object.assign() 的枚举顺序是确定性的。先以升序枚举数 值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定 义的键以它们逗号分隔的顺序插入。

Object.keys() Object.values() 和 Object.entries()

### 原型的动态性

因为从原型上搜索值的过程是动态的，所以即使实例在修改原型 之前已经存在，任何时候对原型对象所做的修改也会在实例上反 映出来。

实例的 [[Prototype]] 指针是在调用构造函数时自动赋值的，这个 指针即使把原型修改为不同的对象也不会变。重写整个原型会切 断最初原型与构造函数的联系，但实例引用的仍然是最初的原 型。记住，实例只有指向原型的指针，没有指向构造函数的指 针。

### 原型的问题

原型的最主要问题源 自它的共享特性。

## 继承

### 原型链

基本 思想就是通过原型继承多个引用类型的属性和方法。重温一下构造函 数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一 个属性指回构造函数，而实例有一个内部指针指向原型。

1. 默认原型，所有应用类型都继承自 Object
2. 原型与继承关系，使用 instanceof 操作符，第二种方式是使用 isPrototypeOf() 方法。
3. 关于方法，子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为 此，这些方法必须在原型赋值之后再添加到原型上。以对象字面量方式创建原型方法会破坏 之前的原型链，因为这相当于重写了原型链
4. 原型链的问题。原型中包含的引用值会在所有实例间共享，这也是为什么属 性通常会在构造函数中定义而不会定义在原型上的原因。原型链的第二个问题是，子类型在实例化时不能给父类型的构造 函数传参。

### 盗用构造函数（对象伪装，或经典继承）

基本思路：在子类构造函数中调用父类构造函数。

1. 传递参数
2. 盗用构造函数的问题：必须在构造函数中定义方法，因此函数不能重用。

### 组合继承

基本的思路是使用原型链继承原型上 的属性和方法，而通过盗用构造函数继承实例属性。

### 原型式继承

```js
function object(o) {
  function F() {}
  F.prototype = o;
  return new F();
}
```

通过增加 Object.create() 方法将原型式继承 的概念规范化。

原型式继承非常适合不需要单独创建构造函数，但仍然需要在对 象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关 对象间共享，跟使用原型模式是一样的。

### 寄生式继承

创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的 场景。 object() 函数不是寄生式继承所必需的，任何返回新对象 的函数都可以在这里使用。

### 寄生式组合继承

组合继承其实也存在效率问题。最主要的效率问题就是父类构造 函数始终会被调用两次：一次在是创建子类原型时调用，另一次是在 子类构造函数中调用。本

基本思路是不通过调用父类构造函数给子类原型赋值， 而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父 类原型，然后将返回的新对象赋值给子类原型。

寄生式组合继承的核心逻辑。这个函数接收两个参数：子类构造函数和父类构造函数。在这个函数内部，第一步是创建父类原型的一个副本。然后，给返回的 prototype 对象设置 constructor 属性，解决由于重写原型导致默认 constructor 丢失的问题。最后将新创建的对象赋值给子类型的原型。

## 类

### 类定义

与函数定义不同的是，虽然函数声明可以提升，但类定义不能。另一个跟函数声明不同的地方是，函数受函数作用域限制，而类 受块作用域限制

类可以包含构造函数方法、实例方法、获取函数、设置函数和静 态类方法，但这些都不是必需的

类表达式的名称是可选的。在把类表达式赋值给变量后，可以通 过 name 属性取得类表达式的名称字符串。但不能在类表达式作用域 外部访问这个标识符。

### 类构造函数

constructor 关键字用于在类定义块内部创建类的构造函数。 方法名 constructor 会告诉解释器在使用 new 操作符创建类的新 实例时，应该调用这个函数。使用 new 调用类的构造函数会执行如下操作。

1. 在内存中创建一个新对象。
2. 这个新对象内部的 [[Prototype]] 指针被赋值为构造函数 的 prototype 属性。
3. 构造函数内部的 this 被赋值为这个新对象（即 this 指向 新对象）。4. 执行构造函数内部的代码（给新对象添加属性）。
4. 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。

### 实例、原型和类成员

1. 实例成员。每次通过 new 调用类标识符时，都会执行类构造函数。在这个 函数内部，可以为新创建的实例（ this ）添加“自有”属性。每个实例都对应一个唯一的成员对象，这意味着所有成员都不会 在原型上共享
2. 原型方法与访问器。为了在实例间共享方法，类定义语法把在类块中定义的方法作为 原型方法。可以把方法定义在类构造函数中或者类块中，但不能在类块中给 原型添加原始值或对象作为成员数据
3. 静态方法。与原型成员类似，每个类上只 能有一个静态成员。静态类方法非常适合作为实例工厂。
4. 非函数原型和类成员。
5. 迭代器与生成器方法。类定义语法支持在原型和类本身上定义生成器方法。因为支持生成器方法，所以可以通过添加一个默认的迭代器，把 类实例变成可迭代对象

### 继承

1. 继承基础。ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥 有 [[Construct]] 和原型的对象。这意味着不 仅可以继承一个类，也可以继承普通的构造函数
2. 构造函数、HomeObject super()。在静态方法中可以通过 super 调用继承的类上定义的静态方法。

   ES6 给类构造函数和静态方法添加了内部特性 [[HomeObject]] ，这个特性是一个指针，指向定义该方法 的对象。这个指针是自动赋值的，而且只能在 JavaScript 引擎内 部访问。 super 始终会定义为 [[HomeObject]] 的原型。

   - super 只能在派生类构造函数和静态方法中使用。
   - 不能单独引用 super 关键字，要么用它调用构造函数，要 么用它引用静态方法。
   - 调用 super() 会调用父类构造函数，并将返回的实例赋值 给 this 。
   - super() 的行为如同调用构造函数，如果需要给父类构造 函数传参，则需要手动传入。
   - 如果没有定义类构造函数，在实例化派生类时会调用 super() ，而且会传入所有传给派生类的参数。
   - 在类构造函数中，不能在调用 super() 之前引用 this 。
   - 如果在派生类中显式定义了构造函数，则要么必须在其中调 用 super() ，要么必须在其中返回一个对象。

3. 通过 new.target 获取抽象基类
4. 继承内置类型。
5. 类混入。把不同类的行为集中到一个类是一种常见的 JavaScript 模式。虽然 ES6 没有显式支持多类继承，但通过现有特性可以轻松地模拟这 种行为。e3tends 关键字后面是一个 JavaScript 表 达式。任何可以解析为一个类或一个构造函数的表达式都是有效 的。这个表达式会在求值类定义时被求值。很多 JavaScript 框架（特别是 React）已经抛弃混入模 式，转向了复合模式（把方法提取到独立的类和辅助对象中， 然后把它们组合起来，但不使用继承）。这反映了那个众所周 知的软件设计原则：“复合胜过继承（composition over inheritance）。”

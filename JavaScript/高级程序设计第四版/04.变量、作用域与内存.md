# 变量、作用域与内存

原始值和引用值

6 种原始值： Undefined 、 Null 、 Boolean 、 Number 、 String 和 Symbol 。

复制值：原始值复制的是值的拷贝，引用值复制的是值的指针

传递参数：所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。对很多开发者来说，这一块 可能会不好理解，毕竟变量有按值和按引用访问，而传参则只有按值传递。

即使 对象是按值传进函数的， 参数也会通过引用访问对象。当函数内部 给参数设置了属性时，函数外部的对象也会反映这个变化， 因为参数指向的对象保存在全局作用域的堆内存上。

- 确定类型

  typeof 虽然对原始值很有用，但它对引用值的用处不大。我们 通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为 了解决这个问题，ECMAScript 提供了 instanceof 操作符

- 执行上下文

  每个上下文都有一个关联的变量对象（variable object），而 这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法 通过代码访问变量对象，但后台处理数据会用到它。

  上下文中的代码在执行的时候，会创建变量对象的一个作用域链 （scope chain）。这个作用域链决定了各级上下文中的代码在访问变 量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用 域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有一个定义变量： arguments 。（全局上下文中没有这个变量。）作用域链中的下一 个变量对象来自包含上下文，再下一个对象来自再下一个包含上下 文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域 链的最后一个变量对象。

- 作用域链
- 作用域链增强

  try/catch with

- 变量声明

  var 变量声明提升
  let const
  标识符查找：如果在局部上下文中找到该标识 符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作 用域链搜索。（注意，作用域链中的对象也有一个原型链，因此 搜索可能涉及每个对象的原型链。）这个过程一直持续到搜索至 全局上下文的变量对象。如果仍然没有找到标识符，则说明其未 声明。

- 垃圾回收

  我们以函数中局部变量的正常生命周期为例。函数中的局部变量 会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应 的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局 部变量了，它占用的内存可以释放，供后面使用。

  JavaScript最常用的垃圾回收策略是标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，这个 变量会被加上存在于上下文中的标记。而不在上下文中的变量，逻辑 上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运 行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下 文的标记。

  1. 通过 const 和 let 声明提升性能
  2. 隐藏类和删除操作。V8在将解释后的 JavaScript代码编译为实际的机器码时会利用“隐藏类”。如果你的 代码非常注重性能，那么这一点可能对你很重要。 运行期间，V8会将创建的对象与隐藏类关联起来，以跟踪它们的 属性特征。能够共享相同隐藏类的对象性能会更好，V8会针对这 种情况进行优化，但不一定总能够做到。
  3. 内存泄漏
  4. 静态分配与对象池
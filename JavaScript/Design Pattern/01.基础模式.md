# 基础模式

## 面向对象的 JavaScript

编程语言按照数据类型大体可以分为两类，一类是静态类型语言，另一类是动态类型语言。

动态类型语言由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。

这一切都建立在鸭子类型（ducktyping）的概念上，鸭子类型的通俗说法是：“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”

利用鸭子类型的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。

### 多态

多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。

使用继承来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括实现继承和接口继承。多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

### 封装

封装的目的是将信息隐藏，封装应该被视为“任何形式的封装”，也就是说，封装不仅仅是隐藏数据，还包括隐藏实现细节、设计细节以及隐藏对象的类型等。

从设计模式的角度出发，封装在更重要的层面体现为封装变化。《设计模式》一书曾提到如下文字：“考虑你的设计中哪些地方可能变化，这种方式与关注会导致重新设计的原因相反。它不是考虑什么时候会迫使你的设计改变，而是考虑你怎样才能够在不重新设计的情况下进行改变。这里的关键在于封装发生变化的概念，这是许多设计模式的主题。”这段文字即是《设计模式》提到的“找到变化并封装之”。《设计模式》一书中共归纳总结了23种设计模式。从意图上区分，这23种设计模式分别被划分为创建型模式、结构型模式和行为型模式。

### 原型模式

原型模式不单是一种设计模式，也被称为一种编程泛型。

所有的JavaScript对象都是从某个对象上克隆而来的。父对象是子对象的原型，从而它们之间形成了一条原型链。当子对象没有需要调用的方法时，会沿着原型链向父对象查找。

我们可以发现原型编程范型至少包括以下基本规则：

- 所有的数据都是对象。
- 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
  JavaScript 是通过克隆Object.prototype来得到新的对象，但实际上并不是每次都真正地克隆了一个新的对象。从内存方面的考虑出发，JavaScript还做了一些额外的处理。
- 对象会记住它的原型。
  对象通过 prototype 或者暴露出的 \__proto__ 指向构造器的原型对象
- 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型。

Peter Norvig曾说，设计模式是对语言不足的补充，如果要使用设计模式，不如去找一门更好的语言。

## this、call 和 apply

this 的指向大致可以分为以下4种：

- 作为对象的方法调用。
- 作为普通函数调用。
- 构造器调用。
  但用new调用构造器时，还要注意一个问题，如果构造器显式地返回了一个object类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的this。
- Function.prototype.call 或 Function.prototype.apply调用。

当使用 call 或者 apply 的时候，如果我们传入的第一个参数为null，函数体内的 this 会指向默认的宿主对象，在浏览器中则是window。

call 接受 this + 数组，apply 接受 this + n个参数

call 和 apply 的用途：

- 改变this指向
- 实现 Function.prototype.bind
- 借用其他对象的方法

## 闭包

在JavaScript中，函数可以用来创造函数作用域。此时的函数像一层半透明的玻璃，在函数里面可以看到外面的变量，而在函数外面则无法看到函数里面的变量。

### 变量的生命周期

对于全局变量来说，全局变量的生存周期当然是永久的，除非我们主动销毁这个全局变量。而对于在函数内用var关键字声明的局部变量来说，当退出函数时，这些局部变量即失去了它们的价值，它们都会随着函数调用的结束而被销毁。

闭包的作用：

- 封装变量
- 延续局部变量的寿命

### 闭包与内存管理

局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为null。

跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非JavaScript的问题。在IE浏览器中，由于 BOM 和 DOM 中的对象是使用 C++ 以 COM 对象的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。

## 高阶函数

高阶函数是指至少满足下列条件之一的函数：

1. 函数可以作为参数被传递；
    - 回调函数
    - Array.prototype.sort
2. 函数可以作为返回值输出。
    - 判断数据的类型
      ```javascript
      var isType = function( type ){
        return function( obj ){
          return Object. prototype. toString. call( obj ) === '[object '+ type +']';
        }
      };
      ```

应用：

- currying
    currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。
- uncurrying
- 函数节流
- 分时函数
- 惰性加载函数
# 第一章 作用域是什么

1. 编译原理

   一段源代码在执行之前会经历三个步骤，称为“编译”：

   - 分词／词法分析

     将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元（token）。这段程序通常会被分解成 为下面这些词法单元： var 、 a 、 = 、 2 、 ; 。空格是否会被当作词法单元，取决于空格在 这门语言中是否具有意义。

   - 解析／语法分析

     将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。

   - 代码生成

     将 AST转换为可执行代码的过程称被称为代码生成。简单来说就是有某种方法可以将`var a = 2;` 的AST 转化为一组机器指令，用来 创建一个叫作`a`的变量（包括分配内存等），并将一个值储存在`a` 中。

   对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。在我们所要讨论的作用域背后， JavaScript引擎用尽了各种办法（比如 JIT， 可以延迟编译甚至实施重编译）来保证性能最佳。任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript编译器首先会对 `var a = 2;`这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。

2. 理解作用域

   1. 程序处理过程中的参与者

      - 引擎：负责整个JavaScript程序的编译及执行过程。
      - 编译器：负责语法分析及代码生成等。
      - 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

   2. 对话

      引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

      编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。编译器会进行如下处理：

      1. 遇到`var a`，编译器会询问作用域是否已经有该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a 。
      2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理`a = 2`这个赋值操作。 引擎运行时会首先询问作用域， 在当前的作用域集合中是否存在一个叫作`a`的 变量。 如果是， 引擎就会使用这个变量；如果否， 引擎会继续查找该变量。

      函数声明不等同于赋值。

   3. 编译器

      引擎会为变量 a 进行`LHS`查询。另外一个查找的类型叫作`RHS`。当变量出现在赋值操作的左侧时进行`LHS`查询，出现在右侧时进行`RHS`查询。

      `RHS`查询与简单地查找某个变量的值相同，而`LHS`查询则是试图找到变量的容器本身，从而可以对其赋值。`RHS`更准确地说是“非左侧”,可以将`RHS`理解成`retrieve his source value`（取到它的源值），这意味着“得到某某的的值”。

3. 作用域嵌套

   当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域（也就是全局作用域）为止。

4. 异常

   `ReferenceError`同作用域判别失败相关， 而`TypeError`则代表作用域判别成功了， 但是对结果的操作是非法或不合理的。




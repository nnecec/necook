# 面向对象的程序设计

在 ECMAScript 的定义中，对象是无序属性的集合，其属性可以包含基本值、对象或者函数。

## 创建对象

### 工厂模式

没有解决对象识别的问题

### 构造函数模式

  - 通过 new 操作符创建新实例
  - 实例中保存有 constructor 属性，指向构造函数
  - 每个方法都在每个实例上重新创建

### 原型模式

只要创建了一个函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。在默认情况下，所有原型对象都会自动获得一个 constructor 属性，这个属性包含一个指向 prototype 属性所在函数的指针。

当调用构造函数创建一个新实例后，该实例的内部将包含一个指针，指向构造函数的原型对象。ECMA-262 第 5 版中管这个指针叫[[Prototype]]，浏览器实现的属性是`__proto__`。这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

- 通过对象字面量形式设置的 prototype 会使 constructor 熟悉指向 Object 构造函数。手动重设 constructor 会使该属性变为可枚举。
- 原型会保持现有原型与任何之前已经存在的对象实例之间的联系，重写原型对象会切断联系。

问题：

- 省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。
- 原型中所有属性是被很多实例共享的，对于包含引用类型值的属性来说，属性值会共享。

### 组合使用构造函数和原型

构造函数模式用于定义实 例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本， 但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数。

### 动态原型模式
### 寄生构造函数模式
### 稳妥构造函数模式

## 继承

原型链：原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。


# Fiber

## 概念

Reconciler 就是我们所说的 Virtul DOM，用于计算新老视图的差异。React 16之前的 reconciler 叫 Stack reconciler。Fiber 是 React 的新 reconciler。

Renderer 则是和平台相关的代码，负责将 View 渲染到不同的平台上。可以看出 reconciler 是React的核心代码，是各个平台共用的。

在现有 React 中，更新过程是同步的，这可能会导致性能问题。

当 React 决定要加载或者更新组件树时，会做很多事，比如调用各个组件的生命周期函数，计算和比对 Virtual DOM，最后更新 DOM 树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那 React 就会一直运行到结束，不会中断。

表面上看，这样的设计似乎是合理的，因为更新过程不会有任何 I/O 操作，完全是 CPU 计算，所以无需异步操作。但当组件树比较庞大的时候，问题就来了。

假如更新一个组件需要1毫秒，如果有200个组件要更新，那就需要200毫秒，在这200毫秒的更新过程中，浏览器那个唯一的主线程都在专心运行更新操作，无暇去做任何其他的事情。在这200毫秒内，用户往一个input元素中输入点什么，敲击键盘也不会获得响应，因为渲染输入按键结果也是浏览器主线程的工作，但是浏览器主线程被 React 占用，最后的结果就是用户敲了按键看不到反应，等 React 更新过程结束之后，按键输入的值会一下子出现在 input 元素里了。

现有的React版本，当组件树很大的时候就会出现这种问题，因为更新过程是同步地一层组件套一层组件，逐渐深入的过程，在更新完所有组件之前不停止，函数的调用栈调用得很深，而且很长时间不会返回。

为了解决这一问题，React 提出了 Fiber 的概念。

Fiber 直译为纤维。可以理解为，React 拥有细分为一根根纤维一样细密的处理事件并发处理机制。

把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。

React Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。

维护每一个分片的数据结构，就是Fiber。

## 

由 reconciler 和 renderer 两个概念引出的是phase的概念。Phase 指的是 React 组件渲染时的阶段。

1. 第一阶段是 reconciliation，这一阶段做的是 Fiber 的 update，然后产出的是 effect list（可以想象成将老的 View 更新到新的状态所需要做的DOM操作的列表）。这一个阶段是没有副作用的，因此这个过程可以被打断，然后恢复执行。
2. 第二阶段是 commit 阶段。Reconciliation 产生的 effect list 只有在 commit 之后才会生效，也就是真正应用到 DOM 中。这一阶段往往不会执行太长时间，因此是同步的，这样也避免了组件内视图层结构和DOM不一致。

一次更新过程会分成多个分片完成，所以完全有可能一个更新任务还没有完成，就被另一个更高优先级的更新过程打断，这时候，优先级高的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。

以render函数为界，第一阶段可能会调用下面这些生命周期函数，说是“可能会调用”是因为不同生命周期调用的函数不同。

- componentWillMount
- componentWillReceiveProps
- shouldComponentUpdate
- componentWillUpdate

下面这些生命周期函数则会在第二阶段调用。

- componentDidMount
- componentDidUpdate
- componentWillUnmount

所以第一阶段的相关生命周期调用函数，在 React 16 之后被认为不安全而弃用。

## 参考

1. [React Fiber是什么 - 程墨Morgan](https://zhuanlan.zhihu.com/p/26027085)